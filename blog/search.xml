<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS单例的写法注意]]></title>
    <url>%2F2018%2F04%2F09%2FiOS%E5%8D%95%E4%BE%8B%E7%9A%84%E5%86%99%E6%B3%95%E6%B3%A8%E6%84%8F%2F</url>
    <content type="text"><![CDATA[12345678单例书写注意，防止别人alloc你的单例出问题！！！单例:单例模式使一个类只有一个实例.单例是在使用过程,保证全局有唯一的一个实例.这样,才能满足统一管理的功能.例如,一个数据库,只需要全局统一的读取,写入操作.不要多个实例去读写.d单例是唯一实例,它不等同于一直伴随这app的生命周期.下面,我会从单例的创建与销毁去分析单例.单例的创建先定义一个静态的instance. static MyClass _instance;重写allocWithZone方法.此方法为对象分配空间必须调用方法.定一个个share的类方法.能够被全局调用的.此方法里需要考虑线程安全问题如果需要copy,需要遵守NSCopying协议,以及在copyWithZone中,直接返回self; 单例的创建方式1234567891011121314151617181920static Myclass _instance;方法一:+(id)shareInstance&#123; @synchronized(self)&#123; if(_instance == nil) _instance = [MyClass alloc] init]; &#125; return _instance;&#125;方法二:+(id)shareInstance&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if(_instance == nil) _instance = [MyClass alloc] init]; &#125;); return _instance;&#125;以上两种方法都是线程安全的.不过苹果官方现在提倡方法二.This method exists for historical reasons; memory zones are no longer used by Objective-C. You should not override this method. 在.h文件里边声明一下+(id)shareInstance;即可[Myclass shareInstance]来创建一个单例对象了。但是这样存在一个风险，就是其他人也可以通过alloc来创建，导致出现一些问题，此时需要重写allocWithZone,里面实现跟方法一,方法二一致就行.12345678+(id)allocWithZone:(struct _NSZone *)zone&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; if(_instance == nil) _instance = [MyClass alloc] init]; &#125;); return _instance;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-KVO的底层实现原理]]></title>
    <url>%2F2017%2F06%2F21%2FiOS-KVO%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[KVO 是 OC 观察者设计模式的一种KVO 的实现依赖于 OC 强大的 RuntimeKVO是Cocoa提供的一种基于KVC的机制 允许一个对象(A)去监听另一个对象(B)的某个属性，当该属性改变时，系统会通知监听的对象(A) 12345678一、KVO的基本使用流程有三步1.添加监听- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullablevoid *)context;（系统还有其他添加方法）2.接收通知- (void)observeValueForKeyPath:(nullableNSString *)keyPath ofObject:(nullableid)object change:(nullableNSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(nullablevoid *)context3.移除监听- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context （系统还有其他移除方法） ##KVO的触发1234567891011121314@property (nonatomic,strong) Person *p;Person *p = [Person new]; _p = p;[p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];#pragma mark - 点击改变 name 的属性-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; static int i = 0;//加上static的目的是每次进来改变i的值。就不会重新初始化了 i++; _p.name = [NSString stringWithFormat:@&quot;%d&quot;,i];&#125;#只要一点击屏幕就会导致_p.name改变，那么就会触发KVO ##KVO原理：通过实现自定义的KVO来理解12简单概括：KVO系统的处理是通过运行时，替换了对象的isa指针对象，并重写了set等方法 1、创建一个Person类2、写一个NSObject+RRKVO.h分类 ##1. Person123456789101112131415161718192021// Person.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject/** name */@property (nonatomic,copy) NSString *name;@end#import &quot;Person.h&quot;@implementation Person//不影响重写set方法-(void)setName:(NSString *)name&#123; _name = [NSString stringWithFormat:@&quot;在不影响重写set方法的情况下加上这句%@&quot;,name];&#125;@end ##2.参照系统KVO1234567// NSObject+RRKVO.h#import &lt;Foundation/Foundation.h&gt;@interface NSObject (RRKVO)- (void)rr_addObserver:(NSObject *_Nullable)observer forKeyPath:(NSString *_Nullable)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;@end 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// NSObject+RRKVO.m#import &quot;NSObject+RRKVO.h&quot;#import &lt;objc/message.h&gt;@implementation NSObject (RRKVO)//self 是 被观察者 （Person）//observer 是 观察者- (void)rr_addObserver:(NSObject *_Nullable)observer forKeyPath:(NSString *_Nullable)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context&#123; /* 1、自定义子类对象 2、重写setName:方法，调用super的，通知观察者 3、修改当前对象的isa指针，只想自定义的子类 */ //1、动态生成一个类 //1.1创建self的子类 NSString *oldClassName = NSStringFromClass([self class]); NSString *newClassName = [@&quot;rrKVO_&quot; stringByAppendingString:oldClassName]; const char *newName = [newClassName UTF8String]; //创建一个类的class Class myClass = objc_allocateClassPair([self class], newName, 0); //注册类 //就可以加入到内存中了 就可以用来alloc init了 objc_registerClassPair(myClass); //2.添加set方法 class_addMethod(myClass, @selector(setName:), (IMP)setName, &quot;v@:@&quot;);//查看官方文档可得 cmd //3.修改isa指针 object_setClass(self, myClass); //4.保存观察者对象 objc_setAssociatedObject(self, @&quot;objc&quot;, observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//相当于给self动态的创建了一个属性&#125;#pragma mark - 1.调用supper的set方法 2.通知外界void setName(id self,SEL _cmd,NSString *newName)&#123; NSLog(@&quot;运行这里&quot;); //调用父类的 //保存子类类型 id class = [self class]; //改变self的isa指针 object_setClass(self, class_getSuperclass(class)); //调用父类的set方法 objc_msgSend(self, @selector(setName:),newName); NSLog(@&quot;修改完毕&quot;); //拿到观察者 id objc = objc_getAssociatedObject(self, @&quot;objc&quot;); //通知观察者 objc_msgSend(objc, @selector(observeValueForKeyPath:ofObject:change:context:),self,@&quot;name&quot;,nil,nil); //改回子类类型 object_setClass(self, class);&#125;@end ##3.应用1234567891011121314151617181920212223242526272829303132333435363738394041#import &quot;ViewController.h&quot;#import &quot;NSObject+RRKVO.h&quot;#import &quot;Person.h&quot;@interface ViewController ()/** person */@property (nonatomic,strong) Person *p;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [Person new]; _p = p; //使用自定义的KVO来监听！Person的name属性 NSLog(@&quot;改之前%@&quot;,[p class]); [p rr_addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil]; NSLog(@&quot;改之后%@&quot;,[p class]);&#125;#pragma mark - 监听到就来了-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; NSLog(@&quot;来到这，%@&quot;,_p.name);//这里会走重写的set方法&#125;#pragma mark - 点击改变 name 的属性-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; static int i = 0;//加上static的目的是每次进来改变i的值。就不会重新初始化了 i++; _p.name = [NSString stringWithFormat:@&quot;%d&quot;,i];&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end ##NSLog122017-06-21 10:57:05.093 004-自己写KVO[7808:2159755] 改之前Person2017-06-21 10:57:05.093 004-自己写KVO[7808:2159755] 改之后rrKVO_Person ##点击屏幕之后NSLog1232017-06-21 10:58:17.213 004-自己写KVO[7808:2159755] 运行这里2017-06-21 10:58:17.213 004-自己写KVO[7808:2159755] 修改完毕2017-06-21 10:58:17.214 004-自己写KVO[7808:2159755] 来到这，在不影响重写set方法的情况下加上这句1]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS封装一个链式编程的应用框架]]></title>
    <url>%2F2017%2F06%2F21%2FiOS%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[写一个能够实现连加（乘除减类似） 12n.add(10).add(20).add(30);n = 60; 首先写一个NSObject的分类，便于所有类都可调用：通过分析Masonry 1- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block； ##我们可以定义此方法为：1+ (int)rr_makeConstraints:(void(^)(SumManager *manager))block； 12SumManager就相当于MASConstraintMaker中的约束制造者在这里担任加法管理者 SumManager.h 12345678910#import &lt;Foundation/Foundation.h&gt;@interface SumManager : NSObject/** */@property (nonatomic,assign) int result;- (SumManager * (^)(int value))add;@end SumManager.m 1234567891011121314151617#import &quot;SumManager.h&quot;@implementation SumManager- (SumManager * (^)(int value))add&#123; return ^(int value)&#123; _result += value; return self; //返回一个“方法调用者” &#125;;&#125;@end NSObject+Sum.h 1234567#import &lt;Foundation/Foundation.h&gt;#import &quot;SumManager.h&quot;@interface NSObject (Sum)+ (int)rr_makeConstraints:(void(^)(SumManager *manager))block;@end NSObject+Sum.m 123456789101112131415#import &quot;NSObject+Sum.h&quot;@implementation NSObject (Sum)+ (int)rr_makeConstraints:(void(^)(SumManager *manager))block&#123; SumManager *mgr = [[SumManager alloc] init]; block(mgr); return mgr.result;&#125;@end 正式使用：ViewController.m 1234567891011121314151617181920212223242526272829303132#import &quot;ViewController.h&quot;#import &quot;NSObject+Sum.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; int sum = [NSObject rr_makeConstraints:^(SumManager *manager) &#123; manager.add(10).add(20).add(30); &#125;]; NSLog(@&quot;sum == %d&quot;,sum);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 输出结果： 12017-06-19 16:44:46.000 002-链式编程思想[3006:1593180] sum == 60]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS高级函数响应式的框架之ReactiveCocoa]]></title>
    <url>%2F2017%2F06%2F13%2F%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%B9%8BReactiveCocoa%2F</url>
    <content type="text"><![CDATA[你真的会用block吗？ 123block作为对象的`属性`block作为方法的`参数`block作为`返回值` (扩展性特别强) 在强化一下： #1.block作为对象的属性1234567Person.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject/* block 在arc下用strong就可以 非ARC下 copy *//** block */@property (nonatomic,copy) void(^block)();@end 123456789101112131415161718192021#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;@interface ViewController ()/** Person *p */@property (nonatomic,strong) Person *p;@end- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [[Person alloc] init]; void(^XDBlock)() = ^() &#123; NSLog(@&quot;XDBlock&quot;); &#125;; //调用 // XDBlock(); p.block = XDBlock; _p = p;&#125;$NSLog：XDBlock #2.block 作为方法的参数12345678Person.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject- (void)eat:(void(^)(NSString *))block;@end 123456Person.m@implementation Person- (void)eat:(void (^)(NSString *))block&#123; block(@&quot;😄&quot;);&#125; 12345678910111213141516171819#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;@interface ViewController ()/** Person *p */@property (nonatomic,strong) Person *p;@end- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [[Person alloc] init]; [p eat:^(NSString *a) &#123; //这里面的代码块就是传递的参数 NSLog(@&quot;吃东西%@&quot;,a); &#125;];&#125;$NSLog：吃东西😄 #3.block作为返回值 (扩展性特别强)12345678Person.h#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject- (void(^)(int))run;@end 1234567Person.m@implementation Person- (void(^)(int))run&#123; return ^(int m)&#123; NSLog(@&quot;跑了%d米&quot;,m); &#125;;&#125; 1234567891011121314151617#import &quot;ViewController.h&quot;#import &quot;Person.h&quot;@interface ViewController ()/** Person *p */@property (nonatomic,strong) Person *p;@end- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p = [[Person alloc] init]; Person *p = [[Person alloc] init];// [p run:3]; p.run(3);&#125;$NSLog：2017-06-13 15:08:32.164 Block[30445:3119801] 跑了3米 首先得知道RAC是什么：ReactiveCocoa-GitHub 1234RAC 是什么？RAC - `ReactiveCocoa` 是一个函数响应式的框架GitHub上的开源框架 在5.0以后的版本就是swift的了 集成ReactiveCocoa框架到项目 项目增大2-2.4M注意纯OC项目目前集成ReactiveObjC (3.0.0)纯swift项目集成ReactiveCocoa (5.0.3)至于为什么，就不再做解释了。 12345现在以OC项目集成为例1、创建项目`RAC-demo`2、终端 cd 到项目 再执行命令`$ vi Podfile`3、把下边的复制到Podfile 123456use_frameworks!platform :ios, &quot;9.0&quot;target &apos;RAC-demo&apos; do pod &apos;ReactiveObjC&apos;, &apos;~&gt; 3.0.0&apos;end 12344、执行命令：$：pod install5、关闭项目，再次打开xcworkspace后缀的文件编译一下没问题。OK 下边可以写代码了： 6、引入框架的头文件 1#import &lt;ReactiveObjC/ReactiveObjC.h&gt; RACSignal信号类 是RAC里面最常见最常用的类 1231、通过这个类创建一个信号RACSignal(默认是冷信号);2、通过订阅者订阅信号（这个信号变为热信号）;3、发送信号 1234567891011121314151617181920212223 //1、创建一个信号RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; //3、发送信号 //subscriber 发送 [subscriber sendNext:@&quot;发送信号&quot;]; return nil; &#125;];//2、订阅信号 //nextBlock这个block 调用：只要订阅者发送数据就调用 //nextBlock 作用：处理数据的 [signal subscribeNext:^(id _Nullable x) &#123; //x就是信号发送的内容 NSLog(@&quot;订阅的信号是: %@&quot;,x); &#125;]; //2017-06-13 16:50:11.399 RAC-demo[32406:3606231] 订阅的信号是发送信号 实现的原理如下： 123456789101112131415161718192021222324252627281.创建RACDynamicSignal信号:[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123;&#125;]&apos;cmd 点进去&apos;+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; return [RACDynamicSignal createSignal:didSubscribe];&#125;createSignal:点进去：可以发现@property (nonatomic, copy, readonly) RACDisposable * (^didSubscribe)(id&lt;RACSubscriber&gt; subscriber);@end@implementation RACDynamicSignal#pragma mark Lifecycle+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123; RACDynamicSignal *signal = [[self alloc] init]; signal-&gt;_didSubscribe = [didSubscribe copy]; return [signal setNameWithFormat:@&quot;+createSignal:&quot;];&#125;&apos;将 &apos;didSubscribe&apos; 被 &apos;_didSubscribe&apos;signal-&gt;_didSubscribe = [didSubscribe copy];保存起来&apos;保存Block《didSubscribe》 12345678910111213141516171819202122232425262728292.订阅信号创建订阅者RACSubscriber&apos;subscribeNext:^(id _Nullable x)cmd 点进去&apos;- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123; NSCParameterAssert(nextBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; return [self subscribe:o];&#125;&apos;subscriberWithNext:nextBlock error:NULL completed:NULL&apos;&apos;cmd 点进去&apos;+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123; RACSubscriber *subscriber = [[self alloc] init]; subscriber-&gt;_next = [next copy]; subscriber-&gt;_error = [error copy]; subscriber-&gt;_completed = [completed copy]; return subscriber;&#125;&apos;将 &apos;next&apos; 被 &apos;_next&apos;subscriber-&gt;_next = [next copy];&apos;&apos;保存起来&apos;保存Block《nextBlock》 12345678910111213141516171819202122232.1 真正订阅信号&apos;cmd 点进去 [self subscribe:o]&apos;self ==&gt; RACDynamicSignal- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; if (self.didSubscribe != NULL) &#123; RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123; RACDisposable *innerDisposable = self.didSubscribe(subscriber); [disposable addDisposable:innerDisposable]; &#125;]; [disposable addDisposable:schedulingDisposable]; &#125; return disposable;&#125;【实现了第一次调用：执行 didSubscribe】&apos;self.didSubscribe(subscriber);&apos; 1234567891011121314151617181920213、发送信号、数据//subscriber ==RACSubscriber 发送 [subscriber sendNext:@&quot;发送信号&quot;];&apos;cmd 点进去 sendNext&apos;- (void)sendNext:(id)value &#123; @synchronized (self) &#123; void (^nextBlock)(id) = [self.next copy]; if (nextBlock == nil) return; nextBlock(value); &#125;&#125;【实现了第二次调用：执行 nextBlock】&apos;nextBlock(value);&apos; //x就是信号发送的内容 NSLog(@&quot;订阅的信号是: %@&quot;,x);//Log:2017-06-13 16:50:11.399 RAC-demo[32406:3606231] 订阅的信号是发送信号 流程图示： RAC的实现原理2-RACDisposable RACDisposable 12345RACDisposable:它可以帮助我们取消订阅.比如：信号发送完毕了 、或者信号发送失败了的时候都需要手动去取消订阅。RACSubscriber(协议):订阅者(发送信号!) 看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &quot;ViewController.h&quot;#import &lt;ReactiveObjC/ReactiveObjC.h&gt;@interface ViewController ()/** id&lt;RACSubscriber&gt; */@property (nonatomic,strong) id&lt;RACSubscriber&gt; subscriber;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //1、创建一个信号 RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; //3、发送信号 //subscriber 发送 [subscriber sendNext:@&quot;发送信号&quot;]; _subscriber = subscriber;//可以用self.,强引用一下subscriber就不会走下边了，不强引用着subscriber 的话subscriber在发送完之后就没了就 自动取消订阅了 //返回值的类型RACDisposable //RACDisposable可以帮助我们取消订阅：信号发送完毕或者失败了。（就像通知的注册和注销） return [RACDisposable disposableWithBlock:^&#123; //清空资源 NSLog(@&quot;到这了&quot;); &#125;]; &#125;]; //2、订阅信号 RACDisposable *disposable = [signal subscribeNext:^(id _Nullable x) &#123; //x就是信号发送的内容 NSLog(@&quot;订阅的信号是: %@&quot;,x); &#125;]; [disposable dispose];//手动 取消订阅 //信号发送完毕了 默认就会取消订阅 //只要订阅者在就不会主动取消订阅 如上边强引用着 subscriber 此时可以手动取消订阅&#125; 原理 12345678910111213subscriber 在信号发送完毕的时候会主动消失，此时如果你再强引用一下它的话，subscriber就不会消失，相当于信号没有发送完，就不会主动取消订阅了。[signal subscribeNext:^(id _Nullable x) 这个方法放入返回值`RACDisposable`类型的 这个类的对象可以帮助我们实现手动取消订阅：RACDisposable *disposable = [signal subscribeNext:^(id _Nullable x) &#123; //x就是信号发送的内容 NSLog(@&quot;订阅的信号是: %@&quot;,x); &#125;]; [disposable dispose];//手动 取消订阅 RAC的实现原理3-RACSubject RACSubject 信号提供者!!,自己可以充当信号,又能够发送信号!! #首先回顾一下 12345RACDisposable:它可以帮助我们取消订阅.信号发送完毕了 ,失败了.RACSubscriber(协议):订阅者(发送信号!)RACSubject :信号提供者!!,自己可以充当信号,又能够发送信号!! ##RACSubject：这个类叫做信号提供者,自己可以充当信号,又能够发送信号!!1@interface RACSubject&lt;ValueType&gt; : RACSignal&lt;ValueType&gt; &lt;RACSubscriber&gt; 123456编程思想：《面向协议的开发》OC里边没有多继承这一说，那么我(RACSubject)想继承另一个类(RACSignal)里的功能：就需要 我(RACSubject) 遵守 订阅者协议&lt; RACSubscriber &gt;，实现订阅者协议的方法，就可以了。就是面向协议的开发的应用场景。 还是三步走: 1231.创建信号2.订阅信号3.发送数据 1234567891011121314151617//1.创建信号 RACSubject *subject = [RACSubject subject]; //2.订阅信号 //不同的信号订阅的方式不一样！！因为类型不一样，所以调用的方法不一样。 //RACSubject处理订阅 ：拿到之前的_subscribers 保存订阅者 [subject subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;接收到的数据 x 是 %@&quot;,x); &#125;]; //3.发送数据 //遍历出所有的订阅者，其实还是调用的nextBlock [subject sendNext:@&quot;数据A&quot;]; 打印的结果： ######2017-06-15 16:18:54.468 RAC-demo[41104:6465743] 接收到的数据 x 是 数据A #多订阅者123456789101112131415161718192021//1.创建信号 RACSubject *subject = [RACSubject subject]; //2.订阅信号 //不同的信号订阅的方式不一样！！因为类型不一样，所以调用的方法不一样。 //RACSubject处理订阅 ：拿到之前的_subscribers 保存订阅者 [subject subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;订阅1⃣️ 接收到的数据 x 是 %@&quot;,x); &#125;]; [subject subscribeNext:^(id _Nullable x) &#123; NSLog(@&quot;订阅2⃣️ 接收到的数据 x 是 %@&quot;,x); &#125;]; //3.发送数据 //遍历出所有的订阅者，其实还是调用的nextBlock [subject sendNext:@&quot;数据A&quot;]; 打印的结果： ######2017-06-15 17:04:56.804 RAC-demo[41379:6621767] 订阅1⃣️ 接收到的数据 x 是 数据A ######2017-06-15 17:04:56.805 RAC-demo[41379:6621767] 订阅2⃣️ 接收到的数据 x 是 数据A #实现原理 1、创建信号订阅管理者(_disposable)、保存订阅者的数组(_subscribers) 1234567891011121314151617181920212223242526272829&quot; cmd &quot;点&quot;subject&quot;进去&quot; [RACSubject subject] &quot;// This should only be used while synchronized on `self`.@property (nonatomic, strong, readonly) NSMutableArray *subscribers;// Contains all of the receiver&apos;s subscriptions to other signals.@property (nonatomic, strong, readonly) RACCompoundDisposable *disposable;+ (instancetype)subject &#123; return [[self alloc] init];&#125;- (instancetype)init &#123; self = [super init]; if (self == nil) return nil; _disposable = [RACCompoundDisposable compoundDisposable]; _subscribers = [[NSMutableArray alloc] initWithCapacity:1]; return self;&#125;- (void)dealloc &#123; [self.disposable dispose];&#125;作者在重写的init方法里面进行了创建信号订阅管理者(_disposable)、保存订阅者的数组(_subscribers)，便于多个订阅者订阅&quot;_disposable&quot;、&quot;_subscribers&quot; 2、订阅信号RACSubject处理订阅 ：拿到之前的_subscribers 保存订阅者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&quot;cmd&quot;点&quot;subscribeNext &quot;进去&quot; [subject subscribeNext:^(id _Nullable x) &#123;&#125;] &quot;- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123; NSCParameterAssert(nextBlock != NULL); RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL]; return [self subscribe:o];&#125;保存BlocknextBlock注意&quot; [self subscribe:o] &quot;&quot;cmd&quot;点&quot;subscribe &quot;进去此处的&quot;self&quot;代表的是&quot;RACSubject&quot;- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123; NSCParameterAssert(subscriber != nil); RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable]; subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable]; NSMutableArray *subscribers = self.subscribers; @synchronized (subscribers) &#123; [subscribers addObject:subscriber]; &#125; [disposable addDisposable:[RACDisposable disposableWithBlock:^&#123; @synchronized (subscribers) &#123; // Since newer subscribers are generally shorter-lived, search // starting from the end of the list. NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123; return obj == subscriber; &#125;]; if (index != NSNotFound) [subscribers removeObjectAtIndex:index]; &#125; &#125;]]; return disposable;&#125;保存所有订阅者[subscribers addObject:subscriber];#@synchronized上锁的原因是：@synchronized（） 的作用是:#创建一个互斥锁，保证在同一时间内没有其它线程对self对象进行修改，起到线程的保护作用，#一般在公用变量的时候使用，如单例模式或者操作类的static变量中使用。这里把订阅管理者disposable返回出去便于 手动 取消订阅 3、发送数据遍历出所有的订阅者，其实还是调用的nextBlock 123456789101112131415161718192021&quot;cmd&quot;点&quot;sendNext&quot;进去&quot;[subject sendNext:@&quot;数据A&quot;]&quot;- (void)sendNext:(id)value &#123; [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:value]; &#125;];&#125;看到&quot;enumerateSubscribersUsingBlock&quot;就知道这是个循环，就是要把之前保存的订阅者一个一个找出发送信号#下边这个方法证实了这个的想法：- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; subscriber))block &#123; NSArray *subscribers; @synchronized (self.subscribers) &#123; subscribers = [self.subscribers copy]; &#125; for (id&lt;RACSubscriber&gt; subscriber in subscribers) &#123; block(subscriber); &#125;&#125; 123456789101112131415#block(subscriber);block一调用就近到了&quot;[subscriber sendNext:value];&quot;方法#pragma mark RACSubscriber- (void)sendNext:(id)value &#123; @synchronized (self) &#123; void (^nextBlock)(id) = [self.next copy]; if (nextBlock == nil) return; nextBlock(value); &#125;&#125;#看到了熟悉的nextBlock(value);这就表示在这里进行了发送数据把保存的nextBlock一执行就实现了数据返回后的处理了。 流程图示： iOS RAC的应用场景之一 在storeboard上边拖个View和一个按钮 关联一下 不好拖到XDView的话先手敲代码,反拖过去：1- (IBAction)btnClick:(id)sender 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849XDView.h#import &lt;UIKit/UIKit.h&gt;#import &lt;ReactiveObjC/ReactiveObjC.h&gt;@interface XDView : UIView/** RACSubject */@property (nonatomic,strong) RACSubject *btnClickSignal;@endXDView.m#import &quot;XDView.h&quot;@implementation XDView-(RACSubject *)btnClickSignal&#123; if (_btnClickSignal == nil) &#123; _btnClickSignal = [RACSubject subject]; &#125; return _btnClickSignal;&#125;- (IBAction)btnClick:(id)sender&#123; [self.btnClickSignal sendNext:@&quot;按钮点击了，数据来了&quot;];&#125;@end#import &quot;ViewController.h&quot;#import &lt;ReactiveObjC/ReactiveObjC.h&gt;#import &quot;XDView.h&quot;@interface ViewController ()@property (strong, nonatomic) IBOutlet XDView *XD_View;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //订阅信号 [self.XD_View.btnClickSignal subscribeNext:^(id _Nullable x) &#123; //想做什么 NSLog(@&quot;x === %@&quot;,x); &#125;];&#125; 点击按钮之后打印结果： 2017-06-15 18:10:51.386 RAC-demo[42160:6990781] x === 按钮点击了，数据来了 #无所不能：123456789101112131415161718192021- (IBAction)btnClick:(id)sender&#123; [self.btnClickSignal sendNext:self.backgroundColor];&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; //订阅信号 [self.XD_View.btnClickSignal subscribeNext:^(id _Nullable x) &#123; //想做什么 NSLog(@&quot;x === %@&quot;,x); self.view.backgroundColor = x; &#125;];&#125; ###点击按钮之后： id 什么都可以代替想怎么玩怎么玩 12345- (void)sendNext:(id)value &#123; [self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:value]; &#125;];&#125; ##value可以是任何：值，方法，代码块等等，例如放个：网络请求。欢迎骚扰：QQ：1434619565]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS11快速安装]]></title>
    <url>%2F2017%2F06%2F12%2FiOS11%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[1、复制链接,使用Safari浏览器打开，安装描述文件: https://d.ruanmei.com/ios/ios_11_beta_profile.mobileconfig 2、浏览器打开 3、安装描述文件 4、点击安装 5、点击重启 6、点击通用，检测软件更新，要求大于2.04G存储空间下载安装 7、小于2.04G存储空间的手机，先清理清理再进行安装。OK了]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS关于接口NSURL里边混合中文及其他特殊字符]]></title>
    <url>%2F2017%2F04%2F08%2F%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3NSURL%E9%87%8C%E8%BE%B9%E6%B7%B7%E5%90%88%E4%B8%AD%E6%96%87%E5%8F%8A%E5%85%B6%E4%BB%96%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[接口里边混合：中文、空格、特殊字符...项目很长时间了，代码量级很大，想要修改怕是几天几夜不能睡觉（稍微夸张）； ####那么有没有更高效更安全的解决办法，不用更改一点代码，答案是：肯定的！！！ 12345解决思路：在执行URLWithString方法的时候，进行处理，那么就需要运用到runtime上无所不能的，交换方法接口:引入run time专用头文件#import &lt;objc/message.h&gt;method_exchangeImplementations(Method m1, Method m2) eg: 1.www.baidu.com/中文123NSURL *url = [NSURL URLWithString:@&quot;www.baidu.com/中文&quot;];NSLog(@&quot;url=%@&quot;,url);打印出来：url=nill 2.www.baidu.com123NSURL *url = [NSURL URLWithString:@&quot;www.baidu.com&quot;];NSLog(@&quot;url=%@&quot;,url);打印出来：url=www.baidu.com 所以这样两种情况在项目中会很常见，下面我们用分类的方法来解决这件头痛的事情：cmd+N新建一个分类 我们知道一个类Class调用的时候最先调用的方法是 ##加载类的load方法+ (void)load 开始上代码： 12345678910111213// NSURL+url.h//// Created by 窦心东 on 2017/6/2.// Copyright © 2017年 窦心东. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@interface NSURL (url)+(instancetype)XD_URLWithString:(NSString *)URLString;@end 1234567891011121314151617181920212223242526272829303132333435363738//// NSURL+url.m//// Created by 窦心东 on 2017/6/2.// Copyright © 2017年 窦心东. All rights reserved.//#import &quot;NSURL+url.h&quot;#import &lt;objc/message.h&gt;@implementation NSURL (url)//加载类的load方法+ (void)load&#123; NSLog(@&quot;来到这%s&quot;,__func__); //1.拿到两个方法 苹果原来的URLWithString 和XD_URLWithString 交换两个方法 //class_getClassMethod获取类方法 class_getInstanceMethod获取对象方法 Method URLWithStr = class_getClassMethod([NSURL class], @selector(URLWithString:)); Method XD_URLWithStr = class_getClassMethod([NSURL class], @selector(XD_URLWithString:)); //2.交换这两个方法 调用A执行B method_exchangeImplementations(URLWithStr, XD_URLWithStr);&#125;+(instancetype)XD_URLWithString:(NSString *)URLString&#123; //NSURL *url = [NSURL URLWithString:URLString]; //上边这一句会出现死循环，因为交换机制调用URLWithString执行XD_URLWithString那么 //直接调用XD_URLWithString，因为刚才通过了交换，就相当于调用URLWithString，就像大话西游上移神换影大法😄 NSURL *url = [NSURL XD_URLWithString:URLString]; if (url == nil) &#123; NSString * urlstr = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]]; url = [NSURL URLWithString:urlstr]; // NSLog(@&quot;该URL为空&quot;) ; return url; &#125;else&#123; return url; &#125;&#125;@end 123456789101112131415161718192021222324252627282930313233343536//// ViewController.m// Created by 窦心东 on 2017/6/2.// Copyright © 2017年 窦心东. All rights reserved.//#import &quot;ViewController.h&quot;#import &lt;objc/message.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //创建一个URL 但是有可能为空 //如果字符串有中文，这个URL就创建不成功，那么我们发送请求就会出错 oc中没有对URL为空的监测机制 Swift里面有可选项 //我需要为URLWithString这个方法添加一个检测是否为空的功能 这个在持续好久的项目中作用特别大，不用改动原来的代码就可以实现 NSURL *url = [NSURL URLWithString:@&quot;www.baidu.com/中文&quot;]; NSLog(@&quot;url=%@&quot;,url);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end#运行结果：2017-06-08 11:27:18.051 06-02 [26223:7685365] 来到这+[NSURL(url) load]2017-06-08 11:27:18.160 06-02[26223:7685365] url=www.baidu.com/%E4%B8%AD%E6%96%87 over有个方法值得注意：1[URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]]; . @interface NSString (NSURLUtilities)//Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters.UTF-8 encoding is used to determine the correct percent encoded characters.Entire URL strings cannot be percent-encoded.This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string. Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.返回一个新的字符串由接收方通过替换所有字符与百分比allowedCharacters集编码字符。utf - 8编码被用来确定正确的百分比编码字符。不能percent-encoded整个URL字符串。这种方法旨在percent-encode组件或子组件的URL字符串,而不是整个URL字符串。外的任何字符allowedCharacters 7位ASCII范围将被忽略。 #ios7.0及之后开始添加此方法12- (nullable NSString *)stringByAddingPercentEncodingWithAllowedCharacters:(NSCharacterSet *)allowedCharactersNS_AVAILABLE(10_9, 7_0); . // Returns a new string made from the receiver by replacing all percent encoded sequences with the matching UTF-8 characters.返回一个新的字符串由接收方通过替换所有百分比与匹配的utf - 8字符编码序列。 #ios7.0及之后开始添加此属性1@property (nullable, readonly, copy) NSString *stringByRemovingPercentEncoding NS_AVAILABLE(10_9, 7_0); . 1- (nullable NSString *)stringByAddingPercentEscapesUsingEncoding:(NSStringEncoding)enc NS_DEPRECATED(10_0, 10_11, 2_0, 9_0, “Use -stringByAddingPercentEncodingWithAllowedCharacters: instead, which always uses the recommended UTF-8 encoding,and which encodes for a specific URL component or subcomponent since each URL component or subcomponent has different rules for what characters are valid.”); #ios9.0及之后开始弃用此方法使用-stringByAddingPercentEncodingWithAllowedCharacters:相反,它总是使用推荐utf - 8编码,编码为一个特定的URL组件或子组件由于每个URL组件或子组件有不同的规则,什么角色都是有效的。 . 1- (nullable NSString *)stringByReplacingPercentEscapesUsingEncoding:(NSStringEncoding)enc NS_DEPRECATED(10_0, 10_11, 2_0, 9_0, “Use -stringByRemovingPercentEncoding instead, which always uses the recommended UTF-8 encoding.”); #ios9.0及之后开始弃用此方法使用-stringByRemovingPercentEncoding相反,总是使用推荐的utf - 8编码。@end 推荐文章：http://www.jianshu.com/p/21a21866e379http://nshipster.cn/nscharacterset/]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin程序加载webView]]></title>
    <url>%2F2017%2F03%2F05%2FKotlin%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BDwebView%2F</url>
    <content type="text"><![CDATA[我的简书:http://www.jianshu.com/u/d1cabf893d7e博客园:http://www.cnblogs.com/520rrGitHub(douxindong) 官方文档 https://developer.android.com/reference/android/webkit/WebView.html【这里提示要加上这段，获取网络权限】安卓要求越来越严格 添加在哪里呢？123456上代码 val webview = WebView(this) setContentView(webview) webview.settings.javaScriptEnabled = true webview.setWebViewClient(WebViewClient()) webview.loadUrl(&quot;https://www.baidu.com&quot;) 下边用图形化 类似Xcode里边的xib或者故事板的原理省去了部分代码的工作量，但是不建议一开始就用，等代码熟练之后再用也不晚。图形化编辑创建webView控件,注意添加ID和约束在编辑部分代码：123myWebView.settings.javaScriptEnabled = truemyWebView.setWebViewClient(WebViewClient())myWebView.loadUrl(&quot;https://www.baidu.com&quot;) 运行效果位置约束不是很好，后边自己研究一下：]]></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin我的第一个kotlin程序]]></title>
    <url>%2F2017%2F03%2F02%2FKotlin%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAkotlin%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[我的简书:http://www.jianshu.com/u/d1cabf893d7e博客园:http://www.cnblogs.com/520rrGitHub:https://github.com/douxindong 这几天被安卓2017年开发者大会刷屏了《Google宣布Kotlin为新的Android一级开发语言》 Kotlin 是一个基于 JVM 的新的编程语言，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。JetBrains，作为目前广受欢迎的Java IDE IntelliJ 的提供商，在 Apache 许可下已经开源其Kotlin 编程语言。Kotlin已正式成为Android官方开发语言。 列举三种可以进行kotlin开发的IDE 【Android Studio】【IntelliJ IDEA】【Eclipse】下面我们用【Android Studio】来开始我们的Kotlin开发之旅（入门篇）goole开发者官网https://developers.google.cn如果您使用Android Studio 官方 Android IDEhttps://developer.android.google.cn/studio/index.html教程http://kotlinlang.org/docs/tutorials/kotlin-android.html中文网：https://www.kotlincn.net/docs/reference/123456789101112131415161718192021222324252627如果您使用IntelliJ IDEA 教程：http://kotlinlang.org/docs/tutorials/getting-started.html如果您使用Eclipse 教程：http://kotlinlang.org/docs/tutorials/getting-started-eclipse.html插件配置：1. cmd加逗号![配置插件.png](http://upload-images.jianshu.io/upload_images/3729815-73ce6f1e0c98fc15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)![下载配置插件.png](http://upload-images.jianshu.io/upload_images/3729815-bced92556ddfa356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)之后重启Android Studio把代码转化成kotlin代码![转换代码.png](http://upload-images.jianshu.io/upload_images/3729815-6a0205eef6dde077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)![转换后.png](http://upload-images.jianshu.io/upload_images/3729815-0438ab5adabbca48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![配置一下](http://upload-images.jianshu.io/upload_images/3729815-546334dbabda37c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)点击同步一下库文件，会从服务器上下载并安装![点击同步一下库文件](http://upload-images.jianshu.io/upload_images/3729815-156e6d077dcd0239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)至此就配置完成kotlin环境 下边就可以开始写代码了：可以参考教程：http://kotlinlang.org/docs/tutorials/kotlin-android.html下边安装下扩展Kotlin Android Extensions Kotlin Android Extensions把这一句apply plugin: ‘kotlin-android-extensions’ 1234567891011121314151617package com.example.douxindong.myapplicationimport android.support.v7.app.AppCompatActivityimport android.os.Bundleimport android.webkit.WebViewClientimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main)//只写这一句代码 根据ID取出myTextView这个控件，直接赋值 myTextView.text = &quot;我在这里&quot; &#125;&#125; 1效果：]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog错误导致部分文件丢失问题解决办法]]></title>
    <url>%2F2016%2F07%2F08%2Fblog%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[欢迎来到 D.Onlyone的私人技术领域! 博客文件丢失解决step11复制blog文件夹到安全地址 step21重新创建blog文件夹在，在根录下 step31拷贝原blog文件夹里边内容到该文件夹下 step412重新生成静态页面$ hexo g step512预览一下$ hexo s step612同步到网路$ hexo d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[葵花宝典]]></title>
    <url>%2F2015%2F06%2F07%2F%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[block：👍1234567891011121314151617181920212223242526272829303132333435363738//代理协议//block 终极宝典//1.block 一般用于反向传值//第二个界面 要求 第一个界面 做点事情/* 1.block 必须定义在第二个界面 2.调用block 3.实现block */block 实质就是一个代码块 定义好代码块 可以用于方向传值 作为中间人来使用在第二个界面的.h文件里面 写协议typedef void(^changeClolorBlock)(UIColor *);协议指针@property (nonatomic,copy) changeClolorBlock changeColor;在第二个页面.m文件里面 调用block 写要求第一个页面做的事情//2. _changeColor([UIColor greenColor]);在第一个页面.m文件里面 实现block//3. vc.changeColor = ^(UIColor *color)&#123; self.view.backgroundColor = color; &#125;;＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊代理：👍/* 代理宝典 //场景 代理一般是用在反向传值 //第二个界面向第一个界面传值 (1,2步是在第二个界面完成) 1.定义代理协议是发生在第二个界面（协议和代理指针） 2.调用协议方法 (3,4步是在第一个界面完成) 3.使用代理,遵循协议 4.实现代理方法 */ #在第二个页面的.h里面写协议123456789101112131415//1.指定协议@protocol TwoVCDelegate &lt;NSObject&gt;- (void)changeColor:(UIColor *)color;@end//2.代理指针@property (nonatomic,assign) id &lt;TwoVCDelegate&gt;delegate;在第二个页面的.m里面 调用协议 代理指针 指向 一个事件[_delegate changeColor:[UIColor greenColor]];在一个页面添加代理协议&lt;TwoVCDelegate&gt;//使用代理 vc.delegate = self;//实现代理- (void)changeColor:(UIColor *)color&#123; self.view.backgroundColor = color;&#125; ##总结：123当你触发事件进入第二个页面的时候，第二个页面反向传值，需要第一个页面做一些事情，执行协议，定义指针，在返回第一个页面的触发事件里面，调用代理 把指针指向要求第一个页面做的事情，第一个页面 遵循协议 ，使用代理方法， 执行代理的事件（注意：代理的使用必须在第一个页面中，实例化第二个页面 的地方，否则不好使。）模式：第一个页面开辟了一套通道，例如button的点击事件中实例化第二个页面 push跳转第二个页面 第二个页面这是需要第一个页面做事情 只有当第一个页面通过点击button的按钮跳转到第二个页面时 ，代理的事件才会在第一个页面执行＊＊＊ ＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊ #通知：👍12在第二个页面的.m文件里面 触发事件的事件中发送 要求第一个页面做的事情 123456789//发射广播 [[NSNotificationCenter defaultCenter] postNotificationName:@"1234" object:[UIColor greenColor]];在第一个页面的.m文件里面 设置接受的收音机//需要创建一个收音机 viewDidLoad中 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeColor:) name:@"1234" object:nil];#pragma mark - 实现广播方法- (void)changeColor:(NSNotification *)notifi&#123; self.view.backgroundColor = notifi.object; &#125;]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作为一个有经验的iOS工程师你这些应该最熟悉]]></title>
    <url>%2F2015%2F04%2F04%2F%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%9C%89%E7%BB%8F%E9%AA%8C%E7%9A%84iOS%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BD%A0%E8%BF%99%E4%BA%9B%E5%BA%94%E8%AF%A5%E6%9C%80%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[1、strong和copy到底怎么理解他们的区别：大部分的时候NSString的属性都是copy，那copy与strong的情况下到底有什么区别呢? 我们遇到的问题是这样的： 在定义一个类的property时候，为property选择strong还是copy特别注意和研究明白的，如果property是NSString或者NSArray及其子类的时候，最好选择使用copy属性修饰。为什么呢？这是为了防止赋值给它的是可变的数据，如果可变的数据发生了变化，那么该property也会发生变化。12345678910111213比如：@property (retain,nonatomic) NSString *rStr;@property (copy, nonatomic) NSString *cStr;- (void)test:&#123; NSMutableString *mStr = [NSMutableStringstringWithFormat:@"abc"]; self.rStr = mStr; self.cStr = mStr; NSLog(@"mStr:%p,%p", mStr,&amp;mStr); NSLog(@"retainStr:%p,%p", _rStr, &amp;_rStr); NSLog(@"copyStr:%p,%p", _cStr, &amp;_cStr);｝ 假如，mStr对象的地址为0x11，也就是0x11是@“abc”的首地址，mStr变量自身在内存中的地址为0x123； 当把mStr赋值给retain的rStr时，rStr对象的地址为0x11，rStr变量自身在内存中的地址为0x124；rStr与mStr指向同样的地址，他们指向的是同一个对象@“abc”，这个对象的地址为0x11，所以他们的值是一样的。 当把mStr赋值给copy的cStr时，cStr对象的地址为0x22，cStr变量自身在内存中的地址0x125；cStr与mStr指向的地址是不一样的，他们指向的是不同的对象，所以copy是深复制，一个新的对象，这个对象的地址为0x22，值为@“abc”。1234如果现在改变mStr的值： [mStr appendString:@"de"]; NSLog(@"retainStr:%@", _rStr); NSLog(@"copyStr:%@", _cStr); 结果1234567使用retain的字串rStr的值：@"abcde",而使用copy的字串cStr的值:@"abc",所以，如果一般情况下，我们都不希望字串的值跟着mStr变化，所以我们一般用copy来设置string的属性。如果希望字串的值跟着赋值的字串的值变化，可以使用strong，retain。注意：上面的情况是针对于当把NSMutableString赋值给NSString的时候，才会有不同，如果是赋值是NSString对象，那么使用copy还是strong，结果都是一样的，因为NSString对象根本就不能改变自身的值，他是不可变的。把一个对象赋值给一个属性变量，当这个对象变化了，如果希望属性变量变化就使用strong属性，如果希望属性变量不跟着变化，就是用copy属性。 由此可以看出：123对源头是NSMutableString的字符串，retain仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种retain方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝。对源头是NSString的字符串，无论是retain声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置，也就是说其实二者都是指针引用，也就是浅拷贝。 另外说明一下，这两者对内存计数的影响都是一样的，都会增加内存引用计数，都需要在最后的时候做处理。1其实说白了，对字符串为啥要用这两种方式？我觉得还是一个安全问题，比如声明的一个NSString *str变量，然后把一个NSMutableString *mStr变量的赋值给它了，如果要求str跟着mStr变化，那么就用retain;如果str不能跟着mStr一起变化，那就用copy。而对于要把NSString类型的字符串赋值给str，那两都没啥区别。不会影响安全性，内存管理也一样。 2、创建一篇新博文1$ hexo new "索要创建的文件名" More info: Writing 运行服务器1$ hexo server More info: Server 生成静态文件 hexo generate（以下缩写）1$ hexo g More info: Generating 同步 hexo deploy（以下缩写）1$ hexo d 完成More info: Deployment]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS即时通讯]]></title>
    <url>%2F2015%2F03%2F01%2FiOS%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[iOS IM开发的一些开源、框架和教程等资料下面收集了开发即时通讯工具，如AIM、ICQ(Oscar 协议)以及Jabber(XMPP协议)的iOS客户端程序的一些开源，可以直接使用或者参考：Oscar协议开发库LibOrange：https://github.com/unixpickle/LibOrange 基于LibOrange库开啊的AIM/ICQ消息通讯工具：https://github.com/chrisballinger/Off-the-Record-iOS XMPP协议Objective-C框架：http://code.google.com/p/xmppframework/ 一些开发教程：如何开发Jabber iOS客户端：https://github.com/funkyboy/Building-a-Jabber-client-for-iOS Building A Jabber Client For iOS: Server SetupBuilding a Jabber Client for iOS: Interface SetupBuilding a Jabber Client for iOS: XMPP Setup]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime]]></title>
    <url>%2F2014%2F05%2F24%2FRuntime%2F</url>
    <content type="text"><![CDATA[重新定义你的OC世界观.这是南峰子版，笔者读过，很不错. 快速开始 （一）类与对象（二）成员变量和属性（三）消息和方法（四）Method Swizzling（五）协议与分类（六）补充&lt; 当你读完南峰子的1可以看看这个;2深入研究Runtime,当你读完上面的内容，在读以下内容就差不多进入了一个新的境界了;3全方位runtime装逼指南. 内存管理深度剖析，知其然，知其所以然内存管理教程和原理剖析（一）;内存管理教程和原理剖析（二）;内存管理教程和原理剖析（三）;内存管理教程和原理剖析（四）;深浅拷贝 多线程，这一块一定要深入理解，尤其是技术总监级别的不一定懂iOS，但是一定懂内存管理和多线程1)IOS开发之多线程技术2)多线程总结 3)多线程详解 ：4)必看 10分钟 搞定JS和iOS的交互 你必须先看这几篇文章：1.web前端开发与iOS终端开发的异同(http://www.open-open.com/lib/view/open1419305655562.html)2.IOS7开发～JavaScriptCore（一）3IOS7开发～JavaScriptCore（二）干货好文章1干货好文章2交互范例http://www.open-open.com/lib/view/open1463553967635.htmliOS Native加载H5中的图片ios 视频录制的三种方式 [直播相关内容]直播相关内容1&amp;version=11020201&amp;pass_ticket=2vSvVDILehoRZdj1MGS0qpcfIh%2FXnQ0HhKl3H3arUtQ%3D)直播相关内容2&amp;version=11020201&amp;pass_ticket=2vSvVDILehoRZdj1MGS0qpcfIh%2FXnQ0HhKl3H3arUtQ%3D) [著名知识点]（上）（中）（下）OC最实用的runtime总结 [一个靠谱工程师必须会了解的：]必看精品1必看精品2必看精品3 ##必看精品（从简单到复杂）http://www.open-open.com/lib/view/open1440165855942.html优酷 ：http://www.open-open.com/lib/view/open1457952546563.html宝库 ： http://www.open-open.com/lib/view/open1456359620073.html]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换博客主题]]></title>
    <url>%2F2014%2F05%2F22%2F%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第一步进入主题链接12语句：# 第一步 &lt;h1&gt; 标签名[更换主题](https://hexo.io/themes/) 第二步进入配置文档123456看文档 示例：$ git clone https://github.com/DrakeLeung/hexo-theme-again.git again“_config.yml” 中的theme：again$ hexo g$ hexo dover!!!! 写作手册 Mastering Markdown]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>HTML5跨平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的私人领域开通咯]]></title>
    <url>%2F2014%2F05%2F20%2F%E4%B8%9C%E5%93%A5%E7%A7%81%E4%BA%BA%E9%A2%86%E5%9F%9F%E5%BC%80%E9%80%9A%E5%92%AF%2F</url>
    <content type="text"><![CDATA[欢迎来到 D.Onlyone的私人技术领域! 这是我的第一个Blog ， 联系我:1434619565@qq.com . 如果你在工作学习中遇到什么问题, 你可以询问我，或者到我的简书:http://www.jianshu.com/u/d1cabf893d7e博客园:http://www.cnblogs.com/520rrGitHub:https://github.com/douxindong查看. 快速开始创建一篇新博文1$ hexo new "索要创建的文件名" More info: Writing 运行服务器1$ hexo server More info: Server 生成静态文件 hexo generate（以下缩写）1$ hexo g More info: Generating 同步 hexo deploy（以下缩写）1$ hexo d 完成More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>HTML5跨平台</tag>
      </tags>
  </entry>
</search>
