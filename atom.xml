<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Onlyone</title>
  
  <subtitle>窦心东的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-20T06:33:34.140Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Onlyone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS单例的写法注意</title>
    <link href="http://yoursite.com/2018/04/09/iOS%E5%8D%95%E4%BE%8B%E7%9A%84%E5%86%99%E6%B3%95%E6%B3%A8%E6%84%8F/"/>
    <id>http://yoursite.com/2018/04/09/iOS单例的写法注意/</id>
    <published>2018-04-09T05:09:39.000Z</published>
    <updated>2019-04-20T06:33:34.140Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">单例书写注意，防止别人alloc你的单例出问题！！！</span><br><span class="line">单例:单例模式使一个类只有一个实例.单例是在使用过程,保证全局有唯一的一个实例.这样,才能满足统一管理的功能.</span><br><span class="line">例如,一个数据库,只需要全局统一的读取,写入操作.不要多个实例去读写.d单例是唯一实例,它不等同于一直伴随这app的生命周期.下面,我会从单例的创建与销毁去分析单例.</span><br><span class="line">单例的创建</span><br><span class="line">先定义一个静态的instance. static MyClass _instance;</span><br><span class="line">重写allocWithZone方法.此方法为对象分配空间必须调用方法.</span><br><span class="line">定一个个share的类方法.能够被全局调用的.此方法里需要考虑线程安全问题</span><br><span class="line">如果需要copy,需要遵守NSCopying协议,以及在copyWithZone中,直接返回self;</span><br></pre></td></tr></table></figure><h4 id="单例的创建方式"><a href="#单例的创建方式" class="headerlink" title="单例的创建方式"></a>单例的创建方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static Myclass _instance;</span><br><span class="line">方法一:</span><br><span class="line">+(id)shareInstance&#123;</span><br><span class="line">   @synchronized(self)&#123;</span><br><span class="line">    if(_instance == nil)</span><br><span class="line">       _instance = [MyClass alloc] init];</span><br><span class="line">   &#125;</span><br><span class="line">   return _instance;</span><br><span class="line">&#125;</span><br><span class="line">方法二:</span><br><span class="line">+(id)shareInstance&#123;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">   if(_instance == nil)</span><br><span class="line">       _instance = [MyClass alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line">   return _instance;</span><br><span class="line">&#125;</span><br><span class="line">以上两种方法都是线程安全的.不过苹果官方现在提倡方法二.</span><br><span class="line">This method exists for historical reasons; memory zones are no longer used by Objective-C. You should not override this method.</span><br></pre></td></tr></table></figure><p>在.h文件里边声明一下+(id)shareInstance;即可<br>[Myclass shareInstance]来创建一个单例对象了。<br>但是这样存在一个风险，就是其他人也可以通过alloc来创建，导致出现一些问题，此时需要重写allocWithZone,里面实现跟方法一,方法二一致就行.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(id)allocWithZone:(struct _NSZone *)zone&#123;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">   if(_instance == nil)</span><br><span class="line">      _instance = [MyClass alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line">   return _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-KVO的底层实现原理</title>
    <link href="http://yoursite.com/2017/06/21/iOS-KVO%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2017/06/21/iOS-KVO的底层实现原理/</id>
    <published>2017-06-21T03:09:14.000Z</published>
    <updated>2018-12-03T08:05:45.900Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>KVO 是 OC  <code>观察者设计模式</code>的一种<br>KVO 的实现依赖于 OC 强大的 Runtime<br>KVO是Cocoa提供的一种基于KVC的机制</p></blockquote><p>允许一个对象(A)去监听另一个对象(B)的某个属性，当该属性改变时，系统会通知监听的对象(A)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一、KVO的基本使用流程有三步</span><br><span class="line"></span><br><span class="line">1.添加监听</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullablevoid *)context;（系统还有其他添加方法）</span><br><span class="line">2.接收通知</span><br><span class="line">- (void)observeValueForKeyPath:(nullableNSString *)keyPath ofObject:(nullableid)object change:(nullableNSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(nullablevoid *)context</span><br><span class="line">3.移除监听</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context （系统还有其他移除方法）</span><br></pre></td></tr></table></figure><p>##KVO的触发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic,strong) Person *p;</span><br><span class="line">Person *p = [Person new];</span><br><span class="line"> _p = p;</span><br><span class="line">[p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line"></span><br><span class="line">#pragma mark - 点击改变 name 的属性</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    static int i = 0;//加上static的目的是每次进来改变i的值。就不会重新初始化了</span><br><span class="line">    i++;</span><br><span class="line">    _p.name = [NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#只要一点击屏幕就会导致_p.name改变，那么就会触发KVO</span><br></pre></td></tr></table></figure></p><p>##KVO原理：通过实现自定义的KVO来理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单概括：</span><br><span class="line">KVO系统的处理是通过运行时，替换了对象的isa指针对象，并重写了set等方法</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-ad17f8c92700ce93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>1、创建一个Person类<br>2、写一个NSObject+RRKVO.h分类</p></blockquote><p>##1. Person<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//  Person.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line">/** name */</span><br><span class="line">@property (nonatomic,copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">//不影响重写set方法</span><br><span class="line">-(void)setName:(NSString *)name&#123;</span><br><span class="line"></span><br><span class="line">    _name = [NSString stringWithFormat:@&quot;在不影响重写set方法的情况下加上这句%@&quot;,name];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>##2.参照系统KVO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//  NSObject+RRKVO.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSObject (RRKVO)</span><br><span class="line">- (void)rr_addObserver:(NSObject *_Nullable)observer forKeyPath:(NSString *_Nullable)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//  NSObject+RRKVO.m</span><br><span class="line"></span><br><span class="line">#import &quot;NSObject+RRKVO.h&quot;</span><br><span class="line">#import &lt;objc/message.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (RRKVO)</span><br><span class="line">//self 是 被观察者 （Person）</span><br><span class="line">//observer 是 观察者</span><br><span class="line">- (void)rr_addObserver:(NSObject *_Nullable)observer forKeyPath:(NSString *_Nullable)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context&#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     1、自定义子类对象</span><br><span class="line">     2、重写setName:方法，调用super的，通知观察者</span><br><span class="line">     3、修改当前对象的isa指针，只想自定义的子类</span><br><span class="line">     */</span><br><span class="line">    //1、动态生成一个类</span><br><span class="line">    //1.1创建self的子类</span><br><span class="line">    NSString *oldClassName = NSStringFromClass([self class]);</span><br><span class="line">    NSString *newClassName = [@&quot;rrKVO_&quot; stringByAppendingString:oldClassName];</span><br><span class="line">    const char *newName = [newClassName UTF8String];</span><br><span class="line">    //创建一个类的class</span><br><span class="line">    Class myClass = objc_allocateClassPair([self class], newName, 0);</span><br><span class="line">    //注册类</span><br><span class="line">    //就可以加入到内存中了 就可以用来alloc init了</span><br><span class="line">    objc_registerClassPair(myClass);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //2.添加set方法</span><br><span class="line">    class_addMethod(myClass, @selector(setName:), (IMP)setName, &quot;v@:@&quot;);//查看官方文档可得 cmd</span><br><span class="line"></span><br><span class="line">    //3.修改isa指针</span><br><span class="line">    object_setClass(self, myClass);</span><br><span class="line"></span><br><span class="line">    //4.保存观察者对象</span><br><span class="line">    objc_setAssociatedObject(self, @&quot;objc&quot;, observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);//相当于给self动态的创建了一个属性</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - 1.调用supper的set方法 2.通知外界</span><br><span class="line">void setName(id self,SEL _cmd,NSString *newName)&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;运行这里&quot;);</span><br><span class="line">    //调用父类的</span><br><span class="line">    //保存子类类型</span><br><span class="line">    id class = [self class];</span><br><span class="line">    //改变self的isa指针</span><br><span class="line">    object_setClass(self, class_getSuperclass(class));</span><br><span class="line">    //调用父类的set方法</span><br><span class="line">    objc_msgSend(self, @selector(setName:),newName);</span><br><span class="line">    NSLog(@&quot;修改完毕&quot;);</span><br><span class="line">    //拿到观察者</span><br><span class="line">    id objc = objc_getAssociatedObject(self, @&quot;objc&quot;);</span><br><span class="line">    //通知观察者</span><br><span class="line">    objc_msgSend(objc, @selector(observeValueForKeyPath:ofObject:change:context:),self,@&quot;name&quot;,nil,nil);</span><br><span class="line">    //改回子类类型</span><br><span class="line">    object_setClass(self, class);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>##3.应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;NSObject+RRKVO.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">/** person */</span><br><span class="line">@property (nonatomic,strong) Person *p;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    _p = p;</span><br><span class="line">    //使用自定义的KVO来监听！Person的name属性</span><br><span class="line">    NSLog(@&quot;改之前%@&quot;,[p class]);</span><br><span class="line">    [p rr_addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">    NSLog(@&quot;改之后%@&quot;,[p class]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - 监听到就来了</span><br><span class="line">-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;来到这，%@&quot;,_p.name);//这里会走重写的set方法</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - 点击改变 name 的属性</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">    static int i = 0;//加上static的目的是每次进来改变i的值。就不会重新初始化了</span><br><span class="line">    i++;</span><br><span class="line">    _p.name = [NSString stringWithFormat:@&quot;%d&quot;,i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>##NSLog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-06-21 10:57:05.093 004-自己写KVO[7808:2159755] 改之前Person</span><br><span class="line">2017-06-21 10:57:05.093 004-自己写KVO[7808:2159755] 改之后rrKVO_Person</span><br></pre></td></tr></table></figure></p><p>##点击屏幕之后NSLog<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-06-21 10:58:17.213 004-自己写KVO[7808:2159755] 运行这里</span><br><span class="line">2017-06-21 10:58:17.213 004-自己写KVO[7808:2159755] 修改完毕</span><br><span class="line">2017-06-21 10:58:17.214 004-自己写KVO[7808:2159755] 来到这，在不影响重写set方法的情况下加上这句1</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;KVO 是 OC  &lt;code&gt;观察者设计模式&lt;/code&gt;的一种&lt;br&gt;KVO 的实现依赖于 OC 强大的 Runtime&lt;br&gt;KVO是Cocoa提供的一种基于KVC的机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;允许一个对象(A)去监听另一
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS封装一个链式编程的应用框架</title>
    <link href="http://yoursite.com/2017/06/21/iOS%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2017/06/21/iOS封装一个链式编程的应用框架/</id>
    <published>2017-06-21T03:08:32.000Z</published>
    <updated>2017-06-21T03:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写一个能够实现连加（乘除减类似）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n.add(10).add(20).add(30);</span><br><span class="line">n = 60;</span><br></pre></td></tr></table></figure><blockquote><p>首先写一个NSObject的分类，便于所有类都可调用：<br>通过分析Masonry</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-9700dfff9d42de46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结构"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block；</span><br></pre></td></tr></table></figure></p><p>##我们可以定义此方法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (int)rr_makeConstraints:(void(^)(SumManager *manager))block；</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SumManager就相当于MASConstraintMaker中的约束制造者</span><br><span class="line">在这里担任加法管理者</span><br></pre></td></tr></table></figure><blockquote><p>SumManager.h</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface SumManager : NSObject</span><br><span class="line"></span><br><span class="line">/**  */</span><br><span class="line">@property (nonatomic,assign) int result;</span><br><span class="line"></span><br><span class="line">- (SumManager * (^)(int value))add;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>SumManager.m</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SumManager.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation SumManager</span><br><span class="line"></span><br><span class="line">- (SumManager * (^)(int value))add&#123;</span><br><span class="line"></span><br><span class="line">    return ^(int value)&#123;</span><br><span class="line"></span><br><span class="line">        _result += value;</span><br><span class="line"></span><br><span class="line">        return self;</span><br><span class="line">        //返回一个“方法调用者”</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>NSObject+Sum.h</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;SumManager.h&quot;</span><br><span class="line">@interface NSObject (Sum)</span><br><span class="line"></span><br><span class="line">+ (int)rr_makeConstraints:(void(^)(SumManager *manager))block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>NSObject+Sum.m</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSObject+Sum.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSObject (Sum)</span><br><span class="line"></span><br><span class="line">+ (int)rr_makeConstraints:(void(^)(SumManager *manager))block&#123;</span><br><span class="line"></span><br><span class="line">    SumManager *mgr = [[SumManager alloc] init];</span><br><span class="line"></span><br><span class="line">    block(mgr);</span><br><span class="line"></span><br><span class="line">    return mgr.result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>正式使用：ViewController.m</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;NSObject+Sum.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    int sum = [NSObject rr_makeConstraints:^(SumManager *manager) &#123;</span><br><span class="line"></span><br><span class="line">        manager.add(10).add(20).add(30);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;sum == %d&quot;,sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017-06-19 16:44:46.000 002-链式编程思想[3006:1593180] sum == 60</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写一个能够实现连加（乘除减类似）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS高级函数响应式的框架之ReactiveCocoa</title>
    <link href="http://yoursite.com/2017/06/13/%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E6%A1%86%E6%9E%B6%E4%B9%8BReactiveCocoa/"/>
    <id>http://yoursite.com/2017/06/13/高级函数响应式的框架之ReactiveCocoa/</id>
    <published>2017-06-13T11:55:11.000Z</published>
    <updated>2017-06-15T10:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你真的会用block吗？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block作为对象的`属性`</span><br><span class="line">block作为方法的`参数`</span><br><span class="line">block作为`返回值` (扩展性特别强)</span><br></pre></td></tr></table></figure><blockquote><p>在强化一下：</p></blockquote><p>#1.block作为对象的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">/* block 在arc下用strong就可以 非ARC下 copy */</span><br><span class="line">/** block */</span><br><span class="line">@property (nonatomic,copy)  void(^block)();</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">/** Person *p */</span><br><span class="line">@property (nonatomic,strong) Person *p;</span><br><span class="line">@end</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line">    void(^XDBlock)() = ^() &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;XDBlock&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    //调用</span><br><span class="line">    // XDBlock();</span><br><span class="line">    p.block = XDBlock;</span><br><span class="line">    _p = p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$NSLog：XDBlock</span><br></pre></td></tr></table></figure><p>#2.block 作为方法的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eat:(void(^)(NSString *))block;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.m</span><br><span class="line">@implementation Person</span><br><span class="line">- (void)eat:(void (^)(NSString *))block&#123;</span><br><span class="line"></span><br><span class="line">    block(@&quot;😄&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">/** Person *p */</span><br><span class="line">@property (nonatomic,strong) Person *p;</span><br><span class="line">@end</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">   Person *p = [[Person alloc] init];</span><br><span class="line">    [p eat:^(NSString *a) &#123;</span><br><span class="line"></span><br><span class="line">        //这里面的代码块就是传递的参数</span><br><span class="line">        NSLog(@&quot;吃东西%@&quot;,a);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$NSLog：吃东西😄</span><br></pre></td></tr></table></figure><p>#3.block作为返回值 (扩展性特别强)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">- (void(^)(int))run;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person.m</span><br><span class="line">@implementation Person</span><br><span class="line">- (void(^)(int))run&#123;</span><br><span class="line">    return ^(int m)&#123;</span><br><span class="line">        NSLog(@&quot;跑了%d米&quot;,m);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">/** Person *p */</span><br><span class="line">@property (nonatomic,strong) Person *p;</span><br><span class="line">@end</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">   Person *p = [[Person alloc] init];</span><br><span class="line">     Person *p = [[Person alloc] init];</span><br><span class="line">//    [p run:3];</span><br><span class="line">     p.run(3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$NSLog：2017-06-13 15:08:32.164 Block[30445:3119801] 跑了3米</span><br></pre></td></tr></table></figure><blockquote><p>首先得知道RAC是什么：<br><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa-GitHub</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RAC 是什么？</span><br><span class="line"></span><br><span class="line">RAC - `ReactiveCocoa` 是一个函数响应式的框架</span><br><span class="line">GitHub上的开源框架 在5.0以后的版本就是swift的了</span><br></pre></td></tr></table></figure><blockquote><p>集成ReactiveCocoa框架到项目 项目增大2-2.4M<br>注意纯OC项目目前集成ReactiveObjC (3.0.0)<br>纯swift项目集成ReactiveCocoa (5.0.3)<br>至于为什么，就不再做解释了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在以OC项目集成为例</span><br><span class="line">1、创建项目`RAC-demo`</span><br><span class="line">2、终端 cd 到项目 再执行命令</span><br><span class="line">`$ vi Podfile`</span><br><span class="line">3、把下边的复制到Podfile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use_frameworks!</span><br><span class="line">platform :ios, &quot;9.0&quot;</span><br><span class="line"></span><br><span class="line">target &apos;RAC-demo&apos; do</span><br><span class="line">  pod &apos;ReactiveObjC&apos;, &apos;~&gt; 3.0.0&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4、执行命令：</span><br><span class="line">$：pod install</span><br><span class="line">5、关闭项目，再次打开xcworkspace后缀的文件编译一下没问题。</span><br><span class="line">OK 下边可以写代码了：</span><br></pre></td></tr></table></figure><blockquote><p>6、引入框架的头文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ReactiveObjC/ReactiveObjC.h&gt;</span><br></pre></td></tr></table></figure><blockquote><p>RACSignal信号类 是RAC里面最常见最常用的类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、通过这个类创建一个信号RACSignal(默认是冷信号);</span><br><span class="line">2、通过订阅者订阅信号（这个信号变为热信号）;</span><br><span class="line">3、发送信号</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> //1、创建一个信号</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line"></span><br><span class="line">        //3、发送信号</span><br><span class="line">        //subscriber 发送</span><br><span class="line"></span><br><span class="line">        [subscriber sendNext:@&quot;发送信号&quot;];</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">//2、订阅信号</span><br><span class="line">    //nextBlock这个block 调用：只要订阅者发送数据就调用</span><br><span class="line">    //nextBlock 作用：处理数据的</span><br><span class="line"></span><br><span class="line">    [signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">        //x就是信号发送的内容</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;订阅的信号是: %@&quot;,x);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    //2017-06-13 16:50:11.399 RAC-demo[32406:3606231] 订阅的信号是发送信号</span><br></pre></td></tr></table></figure><blockquote><p>实现的原理如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.创建RACDynamicSignal信号:</span><br><span class="line"></span><br><span class="line">[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;&#125;]</span><br><span class="line"></span><br><span class="line">&apos;cmd 点进去&apos;</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">return [RACDynamicSignal createSignal:didSubscribe];</span><br><span class="line">&#125;</span><br><span class="line">createSignal:点进去：可以发现</span><br><span class="line">@property (nonatomic, copy, readonly) RACDisposable * (^didSubscribe)(id&lt;RACSubscriber&gt; subscriber);</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation RACDynamicSignal</span><br><span class="line"></span><br><span class="line">#pragma mark Lifecycle</span><br><span class="line"></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">RACDynamicSignal *signal = [[self alloc] init];</span><br><span class="line">signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class="line">return [signal setNameWithFormat:@&quot;+createSignal:&quot;];</span><br><span class="line">&#125;</span><br><span class="line">&apos;将 &apos;didSubscribe&apos; 被 &apos;_didSubscribe&apos;</span><br><span class="line">signal-&gt;_didSubscribe = [didSubscribe copy];</span><br><span class="line">保存起来&apos;</span><br><span class="line"></span><br><span class="line">保存Block《didSubscribe》</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">2.订阅信号</span><br><span class="line"></span><br><span class="line">创建订阅者</span><br><span class="line">RACSubscriber</span><br><span class="line"></span><br><span class="line">&apos;subscribeNext:^(id  _Nullable x)</span><br><span class="line">cmd 点进去&apos;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</span><br><span class="line">NSCParameterAssert(nextBlock != NULL);</span><br><span class="line"></span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</span><br><span class="line">return [self subscribe:o];</span><br><span class="line">&#125;</span><br><span class="line">&apos;subscriberWithNext:nextBlock error:NULL completed:NULL&apos;</span><br><span class="line">&apos;cmd 点进去&apos;</span><br><span class="line">+ (instancetype)subscriberWithNext:(void (^)(id x))next error:(void (^)(NSError *error))error completed:(void (^)(void))completed &#123;</span><br><span class="line">RACSubscriber *subscriber = [[self alloc] init];</span><br><span class="line"></span><br><span class="line">subscriber-&gt;_next = [next copy];</span><br><span class="line">subscriber-&gt;_error = [error copy];</span><br><span class="line">subscriber-&gt;_completed = [completed copy];</span><br><span class="line"></span><br><span class="line">return subscriber;</span><br><span class="line">&#125;</span><br><span class="line">&apos;将 &apos;next&apos; 被 &apos;_next&apos;</span><br><span class="line">subscriber-&gt;_next = [next copy];&apos;</span><br><span class="line">&apos;保存起来&apos;</span><br><span class="line">保存Block《nextBlock》</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2.1 真正订阅信号</span><br><span class="line">&apos;cmd 点进去 [self subscribe:o]&apos;</span><br><span class="line">self ==&gt; RACDynamicSignal</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">NSCParameterAssert(subscriber != nil);</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line">if (self.didSubscribe != NULL) &#123;</span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">RACDisposable *innerDisposable = self.didSubscribe(subscriber);</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;</span><br><span class="line">【实现了第一次调用：执行   didSubscribe】</span><br><span class="line">&apos;self.didSubscribe(subscriber);&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">3、发送信号、数据</span><br><span class="line">//subscriber ==RACSubscriber 发送</span><br><span class="line"></span><br><span class="line">        [subscriber sendNext:@&quot;发送信号&quot;];</span><br><span class="line"></span><br><span class="line">&apos;cmd 点进去 sendNext&apos;</span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">void (^nextBlock)(id) = [self.next copy];</span><br><span class="line">if (nextBlock == nil) return;</span><br><span class="line"></span><br><span class="line">nextBlock(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">【实现了第二次调用：执行   nextBlock】</span><br><span class="line">&apos;nextBlock(value);&apos;</span><br><span class="line"></span><br><span class="line"> //x就是信号发送的内容</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;订阅的信号是: %@&quot;,x);</span><br><span class="line">//Log:2017-06-13 16:50:11.399 RAC-demo[32406:3606231] 订阅的信号是发送信号</span><br></pre></td></tr></table></figure><p>流程图示：</p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-e5e9fbbfd02f5e4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="实现原理图示"></p><p>RAC的实现原理2-RACDisposable</p><blockquote><p>RACDisposable</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACDisposable:它可以帮助我们取消订阅.</span><br><span class="line"></span><br><span class="line">比如：信号发送完毕了 、或者信号发送失败了的时候都需要手动去取消订阅。</span><br><span class="line"></span><br><span class="line">RACSubscriber(协议):订阅者(发送信号!)</span><br></pre></td></tr></table></figure><blockquote><p>看代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;ReactiveObjC/ReactiveObjC.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">/** id&lt;RACSubscriber&gt;  */</span><br><span class="line">@property (nonatomic,strong)  id&lt;RACSubscriber&gt; subscriber;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">     //1、创建一个信号</span><br><span class="line">    RACSignal *signal = [RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line"></span><br><span class="line">        //3、发送信号</span><br><span class="line">        //subscriber 发送</span><br><span class="line">        [subscriber sendNext:@&quot;发送信号&quot;];</span><br><span class="line"></span><br><span class="line">        _subscriber = subscriber;//可以用self.,强引用一下subscriber就不会走下边了，不强引用着subscriber 的话subscriber在发送完之后就没了就 自动取消订阅了</span><br><span class="line"></span><br><span class="line">        //返回值的类型RACDisposable</span><br><span class="line">        //RACDisposable可以帮助我们取消订阅：信号发送完毕或者失败了。（就像通知的注册和注销）</span><br><span class="line">        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">            //清空资源</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;到这了&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    //2、订阅信号</span><br><span class="line"></span><br><span class="line">   RACDisposable *disposable = [signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">        //x就是信号发送的内容</span><br><span class="line">        NSLog(@&quot;订阅的信号是: %@&quot;,x);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    [disposable dispose];//手动 取消订阅</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //信号发送完毕了 默认就会取消订阅</span><br><span class="line">    //只要订阅者在就不会主动取消订阅 如上边强引用着 subscriber 此时可以手动取消订阅</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原理</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">subscriber 在信号发送完毕的时候会主动消失，</span><br><span class="line">此时如果你再强引用一下它的话，</span><br><span class="line">subscriber就不会消失，相当于信号没有发送完，就不会主动取消订阅了。</span><br><span class="line"></span><br><span class="line">[signal subscribeNext:^(id  _Nullable x)  这个方法放入返回值`RACDisposable`类型的 这个类的对象可以帮助我们实现手动取消订阅：</span><br><span class="line"></span><br><span class="line">RACDisposable *disposable = [signal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">        //x就是信号发送的内容</span><br><span class="line">        NSLog(@&quot;订阅的信号是: %@&quot;,x);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    [disposable dispose];//手动 取消订阅</span><br></pre></td></tr></table></figure><p>RAC的实现原理3-RACSubject</p><blockquote><p>RACSubject 信号提供者!!,自己可以充当信号,又能够发送信号!!</p></blockquote><p>#首先回顾一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACDisposable:它可以帮助我们取消订阅.信号发送完毕了 ,失败了.</span><br><span class="line"></span><br><span class="line">RACSubscriber(协议):订阅者(发送信号!)</span><br><span class="line"></span><br><span class="line">RACSubject :信号提供者!!,自己可以充当信号,又能够发送信号!!</span><br></pre></td></tr></table></figure><p>##RACSubject：这个类叫做信号提供者,自己可以充当信号,又能够发送信号!!<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface RACSubject&lt;ValueType&gt; : RACSignal&lt;ValueType&gt; &lt;RACSubscriber&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编程思想：《面向协议的开发》</span><br><span class="line"></span><br><span class="line">OC里边没有多继承这一说，那么我(RACSubject)想继承另一个类(RACSignal)里的功能：</span><br><span class="line">就需要 我(RACSubject) 遵守 订阅者协议&lt; RACSubscriber &gt;，实现订阅者协议的方法，就可以了。</span><br><span class="line"></span><br><span class="line">就是面向协议的开发的应用场景。</span><br></pre></td></tr></table></figure><blockquote><p>还是三步走:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建信号</span><br><span class="line">2.订阅信号</span><br><span class="line">3.发送数据</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//1.创建信号</span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    //2.订阅信号</span><br><span class="line">    //不同的信号订阅的方式不一样！！因为类型不一样，所以调用的方法不一样。</span><br><span class="line">    //RACSubject处理订阅 ：拿到之前的_subscribers 保存订阅者</span><br><span class="line">    [subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;接收到的数据 x 是 %@&quot;,x);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //3.发送数据</span><br><span class="line">    //遍历出所有的订阅者，其实还是调用的nextBlock</span><br><span class="line">    [subject sendNext:@&quot;数据A&quot;];</span><br></pre></td></tr></table></figure><p>打印的结果：</p><blockquote><p>######2017-06-15 16:18:54.468 RAC-demo[41104:6465743] 接收到的数据 x 是 数据A</p></blockquote><p>#多订阅者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//1.创建信号</span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    //2.订阅信号</span><br><span class="line">    //不同的信号订阅的方式不一样！！因为类型不一样，所以调用的方法不一样。</span><br><span class="line">    //RACSubject处理订阅 ：拿到之前的_subscribers 保存订阅者</span><br><span class="line">    [subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;订阅1⃣️ 接收到的数据 x 是 %@&quot;,x);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    [subject subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;订阅2⃣️ 接收到的数据 x 是 %@&quot;,x);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //3.发送数据</span><br><span class="line">    //遍历出所有的订阅者，其实还是调用的nextBlock</span><br><span class="line">    [subject sendNext:@&quot;数据A&quot;];</span><br></pre></td></tr></table></figure></p><p>打印的结果：</p><blockquote><p>######2017-06-15 17:04:56.804 RAC-demo[41379:6621767] 订阅1⃣️ 接收到的数据 x 是 数据A</p></blockquote><p>######2017-06-15 17:04:56.805 RAC-demo[41379:6621767] 订阅2⃣️ 接收到的数据 x 是 数据A</p><p>#实现原理</p><blockquote><p>1、创建信号<br>订阅管理者(_disposable)、保存订阅者的数组(_subscribers)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&quot; cmd &quot;点&quot;subject&quot;进去</span><br><span class="line">&quot; [RACSubject subject] &quot;</span><br><span class="line"></span><br><span class="line">// This should only be used while synchronized on `self`.</span><br><span class="line">@property (nonatomic, strong, readonly) NSMutableArray *subscribers;</span><br><span class="line"></span><br><span class="line">// Contains all of the receiver&apos;s subscriptions to other signals.</span><br><span class="line">@property (nonatomic, strong, readonly) RACCompoundDisposable *disposable;</span><br><span class="line"></span><br><span class="line">+ (instancetype)subject &#123;</span><br><span class="line">return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self == nil) return nil;</span><br><span class="line"></span><br><span class="line">_disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">_subscribers = [[NSMutableArray alloc] initWithCapacity:1];</span><br><span class="line"></span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">[self.disposable dispose];</span><br><span class="line">&#125;</span><br><span class="line">作者在重写的init方法里面进行了创建信号订阅管理者(_disposable)、保存订阅者的数组(_subscribers)，</span><br><span class="line">便于多个订阅者订阅</span><br><span class="line">&quot;_disposable&quot;、&quot;_subscribers&quot;</span><br></pre></td></tr></table></figure><blockquote><p>2、订阅信号<br>RACSubject处理订阅 ：拿到之前的_subscribers 保存订阅者</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&quot;cmd&quot;点&quot;subscribeNext &quot;进去</span><br><span class="line">&quot; [subject subscribeNext:^(id  _Nullable x) &#123;&#125;] &quot;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock &#123;</span><br><span class="line">NSCParameterAssert(nextBlock != NULL);</span><br><span class="line"></span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:NULL completed:NULL];</span><br><span class="line">return [self subscribe:o];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">保存Block</span><br><span class="line">nextBlock</span><br><span class="line"></span><br><span class="line">注意&quot; [self subscribe:o] &quot;</span><br><span class="line">&quot;cmd&quot;点&quot;subscribe &quot;进去</span><br><span class="line">此处的&quot;self&quot;代表的是&quot;RACSubject&quot;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">NSCParameterAssert(subscriber != nil);</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:self disposable:disposable];</span><br><span class="line"></span><br><span class="line">NSMutableArray *subscribers = self.subscribers;</span><br><span class="line">@synchronized (subscribers) &#123;</span><br><span class="line">[subscribers addObject:subscriber];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">@synchronized (subscribers) &#123;</span><br><span class="line">// Since newer subscribers are generally shorter-lived, search</span><br><span class="line">// starting from the end of the list.</span><br><span class="line">NSUInteger index = [subscribers indexOfObjectWithOptions:NSEnumerationReverse passingTest:^ BOOL (id&lt;RACSubscriber&gt; obj, NSUInteger index, BOOL *stop) &#123;</span><br><span class="line">return obj == subscriber;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">if (index != NSNotFound) [subscribers removeObjectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line">return disposable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">保存所有订阅者</span><br><span class="line">[subscribers addObject:subscriber];</span><br><span class="line"></span><br><span class="line">#@synchronized上锁的原因是：@synchronized（） 的作用是:</span><br><span class="line">#创建一个互斥锁，保证在同一时间内没有其它线程对self对象进行修改，起到线程的保护作用，</span><br><span class="line">#一般在公用变量的时候使用，如单例模式或者操作类的static变量中使用。</span><br><span class="line"></span><br><span class="line">这里把订阅管理者disposable返回出去便于 手动 取消订阅</span><br></pre></td></tr></table></figure><blockquote><p>3、发送数据<br>遍历出所有的订阅者，其实还是调用的nextBlock</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&quot;cmd&quot;点&quot;sendNext&quot;进去</span><br><span class="line">&quot;[subject sendNext:@&quot;数据A&quot;]&quot;</span><br><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">[self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">看到&quot;enumerateSubscribersUsingBlock&quot;就知道这是个循环，</span><br><span class="line">就是要把之前保存的订阅者一个一个找出发送信号</span><br><span class="line">#下边这个方法证实了这个的想法：</span><br><span class="line">- (void)enumerateSubscribersUsingBlock:(void (^)(id&lt;RACSubscriber&gt; subscriber))block &#123;</span><br><span class="line">NSArray *subscribers;</span><br><span class="line">@synchronized (self.subscribers) &#123;</span><br><span class="line">subscribers = [self.subscribers copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (id&lt;RACSubscriber&gt; subscriber in subscribers) &#123;</span><br><span class="line">block(subscriber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3729815-737cf7e9514ae48d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#block(subscriber);</span><br><span class="line">block一调用就近到了&quot;[subscriber sendNext:value];&quot;方法</span><br><span class="line">#pragma mark RACSubscriber</span><br><span class="line"></span><br><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">void (^nextBlock)(id) = [self.next copy];</span><br><span class="line">if (nextBlock == nil) return;</span><br><span class="line"></span><br><span class="line">nextBlock(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#看到了熟悉的</span><br><span class="line">nextBlock(value);</span><br><span class="line">这就表示在这里进行了发送数据把保存的nextBlock一执行就实现了数据返回后的处理了。</span><br></pre></td></tr></table></figure></p><p>流程图示：<br><img src="http://upload-images.jianshu.io/upload_images/3729815-e927afead5df870e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt="实现原理图示.png"></p><p>iOS RAC的应用场景之一</p><blockquote><p>在storeboard上边拖个View和一个按钮</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-c2229f263957e503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="在storeboard上边拖个View和一个按钮"></p><blockquote><p>关联一下</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-6f4bd54dddd04bae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="关联一下"></p><p>不好拖到XDView的话先手敲代码,反拖过去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)btnClick:(id)sender</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-fd270d2021a8215b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">XDView.h</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &lt;ReactiveObjC/ReactiveObjC.h&gt;</span><br><span class="line">@interface XDView : UIView</span><br><span class="line">/** RACSubject */</span><br><span class="line">@property (nonatomic,strong) RACSubject *btnClickSignal;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">XDView.m</span><br><span class="line">#import &quot;XDView.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation XDView</span><br><span class="line"></span><br><span class="line">-(RACSubject *)btnClickSignal&#123;</span><br><span class="line"></span><br><span class="line">    if (_btnClickSignal == nil) &#123;</span><br><span class="line">        _btnClickSignal = [RACSubject subject];</span><br><span class="line">    &#125;</span><br><span class="line">    return _btnClickSignal;</span><br><span class="line">&#125;</span><br><span class="line">- (IBAction)btnClick:(id)sender&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   [self.btnClickSignal sendNext:@&quot;按钮点击了，数据来了&quot;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;ReactiveObjC/ReactiveObjC.h&gt;</span><br><span class="line">#import &quot;XDView.h&quot;</span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property (strong, nonatomic) IBOutlet XDView *XD_View;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //订阅信号</span><br><span class="line">    [self.XD_View.btnClickSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        //想做什么</span><br><span class="line">        NSLog(@&quot;x === %@&quot;,x);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>点击按钮之后打印结果：</p><blockquote><p>2017-06-15 18:10:51.386 RAC-demo[42160:6990781] x === 按钮点击了，数据来了</p></blockquote><p>#无所不能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)btnClick:(id)sender&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     [self.btnClickSignal sendNext:self.backgroundColor];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    //订阅信号</span><br><span class="line">    [self.XD_View.btnClickSignal subscribeNext:^(id  _Nullable x) &#123;</span><br><span class="line">        //想做什么</span><br><span class="line">        NSLog(@&quot;x === %@&quot;,x);</span><br><span class="line">        self.view.backgroundColor = x;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###点击按钮之后：</p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-716f8b9df05b7fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt="效果"></p><blockquote><p> id 什么都可以代替想怎么玩怎么玩</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendNext:(id)value &#123;</span><br><span class="line">[self enumerateSubscribersUsingBlock:^(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##value可以是任何：值，方法，代码块等等，例如放个：网络请求。<br>欢迎骚扰：QQ：1434619565</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;你真的会用block吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span
      
    
    </summary>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS11快速安装</title>
    <link href="http://yoursite.com/2017/06/12/iOS11%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2017/06/12/iOS11快速安装/</id>
    <published>2017-06-12T02:35:08.000Z</published>
    <updated>2017-06-12T02:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1、复制链接,使用Safari浏览器打开，安装描述文件:</p></blockquote><p><code>https://d.ruanmei.com/ios/ios_11_beta_profile.mobileconfig</code></p><blockquote><p>2、浏览器打开</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-b6d06b1c2f0fa933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="浏览器打开"></p><blockquote><p>3、安装描述文件</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-188b4cfd1925fea9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="安装描述文件"></p><blockquote><p>4、点击安装</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-68aad06dd2e2cb69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="点击安装"></p><blockquote><p>5、点击重启</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-e76bf56e1ad62d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="点击重启"></p><blockquote><p>6、点击通用，检测软件更新，要求大于2.04G存储空间下载安装</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-f03f4c22d82a0b93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="下载安装"></p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-23db63257e0111f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="小于2.04G"></p><blockquote><p>7、小于2.04G存储空间的手机，先清理清理再进行安装。<br>OK了</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;1、复制链接,使用Safari浏览器打开，安装描述文件:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;https://d.ruanmei.com/ios/ios_11_beta_profile.mobileconfig&lt;/code&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS关于接口NSURL里边混合中文及其他特殊字符</title>
    <link href="http://yoursite.com/2017/04/08/%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3NSURL%E9%87%8C%E8%BE%B9%E6%B7%B7%E5%90%88%E4%B8%AD%E6%96%87%E5%8F%8A%E5%85%B6%E4%BB%96%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2017/04/08/关于接口NSURL里边混合中文及其他特殊字符/</id>
    <published>2017-04-08T06:40:55.000Z</published>
    <updated>2017-06-12T02:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>接口</strong>里边混合：<code>中文</code>、<code>空格</code>、<code>特殊字符...</code>项目很长时间了，代码量级很大，想要修改怕是几天几夜不能睡觉（稍微夸张）；</p></blockquote><p>####那么有没有更高效更安全的解决办法，不用更改一点代码，答案是：肯定的！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决思路：在执行URLWithString方法的时候，进行处理，那么就需要运用到runtime上无所不能的，交换方法接口:</span><br><span class="line"></span><br><span class="line">引入run time专用头文件#import &lt;objc/message.h&gt;</span><br><span class="line"></span><br><span class="line">method_exchangeImplementations(Method m1, Method m2)</span><br></pre></td></tr></table></figure><p><code>eg:</code></p><p>1.<code>www.baidu.com/中文</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;www.baidu.com/中文&quot;];</span><br><span class="line">NSLog(@&quot;url=%@&quot;,url);</span><br><span class="line">打印出来：url=nill</span><br></pre></td></tr></table></figure></p><p>2.<code>www.baidu.com</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;www.baidu.com&quot;];</span><br><span class="line">NSLog(@&quot;url=%@&quot;,url);</span><br><span class="line">打印出来：url=www.baidu.com</span><br></pre></td></tr></table></figure></p><blockquote><p>所以这样两种情况在项目中会很常见，下面我们用分类的方法来解决这件头痛的事情：<br><code>cmd+N</code><br>新建一个分类</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/3729815-ae91f0ef9fd777ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="cateory.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-f78e6bdf7d8d8f0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="url.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-a02f4fbd21066d89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="(NSUrl + url).png"></p><p>我们知道一个类Class调用的时候最先调用的方法是</p><p>##加载类的load方法<br><code>+ (void)load</code></p><blockquote><p>开始上代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//  NSURL+url.h</span><br><span class="line">//</span><br><span class="line">//  Created by 窦心东 on 2017/6/2.</span><br><span class="line">//  Copyright © 2017年 窦心东. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSURL (url)</span><br><span class="line"></span><br><span class="line">+(instancetype)XD_URLWithString:(NSString *)URLString;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  NSURL+url.m</span><br><span class="line">//</span><br><span class="line">//  Created by 窦心东 on 2017/6/2.</span><br><span class="line">//  Copyright © 2017年 窦心东. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;NSURL+url.h&quot;</span><br><span class="line">#import &lt;objc/message.h&gt;</span><br><span class="line">@implementation NSURL (url)</span><br><span class="line">//加载类的load方法</span><br><span class="line"></span><br><span class="line">+ (void)load&#123;</span><br><span class="line">    NSLog(@&quot;来到这%s&quot;,__func__);</span><br><span class="line">    //1.拿到两个方法 苹果原来的URLWithString 和XD_URLWithString 交换两个方法</span><br><span class="line">    //class_getClassMethod获取类方法   class_getInstanceMethod获取对象方法</span><br><span class="line">    Method URLWithStr = class_getClassMethod([NSURL class], @selector(URLWithString:));</span><br><span class="line">    Method XD_URLWithStr = class_getClassMethod([NSURL class], @selector(XD_URLWithString:));</span><br><span class="line">    //2.交换这两个方法 调用A执行B</span><br><span class="line">    method_exchangeImplementations(URLWithStr, XD_URLWithStr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">+(instancetype)XD_URLWithString:(NSString *)URLString&#123;</span><br><span class="line">    //NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    //上边这一句会出现死循环，因为交换机制调用URLWithString执行XD_URLWithString那么</span><br><span class="line">    //直接调用XD_URLWithString，因为刚才通过了交换，就相当于调用URLWithString，就像大话西游上移神换影大法😄</span><br><span class="line">    NSURL *url = [NSURL XD_URLWithString:URLString];</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">       NSString * urlstr = [URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]];</span><br><span class="line">        url = [NSURL URLWithString:urlstr];</span><br><span class="line">        //        NSLog(@&quot;该URL为空&quot;) ;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  ViewController.m</span><br><span class="line">//  Created by 窦心东 on 2017/6/2.</span><br><span class="line">//  Copyright © 2017年 窦心东. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;objc/message.h&gt;</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //创建一个URL 但是有可能为空</span><br><span class="line">    //如果字符串有中文，这个URL就创建不成功，那么我们发送请求就会出错  oc中没有对URL为空的监测机制 Swift里面有可选项</span><br><span class="line">    //我需要为URLWithString这个方法添加一个检测是否为空的功能 这个在持续好久的项目中作用特别大，不用改动原来的代码就可以实现</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;www.baidu.com/中文&quot;];</span><br><span class="line">    NSLog(@&quot;url=%@&quot;,url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">#运行结果：</span><br><span class="line">2017-06-08 11:27:18.051 06-02 [26223:7685365] 来到这+[NSURL(url) load]</span><br><span class="line">2017-06-08 11:27:18.160 06-02[26223:7685365] url=www.baidu.com/%E4%B8%AD%E6%96%87</span><br></pre></td></tr></table></figure><blockquote><p>over<br>有个方法值得注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[URLString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]];</span><br></pre></td></tr></table></figure></p></blockquote><p>.</p><blockquote><p>@interface NSString (NSURLUtilities)<br>//Returns a new string made from the receiver by replacing all characters not in the allowedCharacters set with percent encoded characters.<br>UTF-8 encoding is used to determine the correct percent encoded characters.<br>Entire URL strings cannot be percent-encoded.<br>This method is intended to percent-encode an URL component or subcomponent string, NOT the entire URL string.<br> Any characters in allowedCharacters outside of the 7-bit ASCII range are ignored.<br>返回一个新的字符串由接收方通过替换所有字符与百分比allowedCharacters集编码字符。utf - 8编码被用来确定正确的百分比编码字符。不能percent-encoded整个URL字符串。这种方法旨在percent-encode组件或子组件的URL字符串,而不是整个URL字符串。外的任何字符allowedCharacters 7位ASCII范围将被忽略。</p></blockquote><p>#ios7.0及之后开始添加此方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)stringByAddingPercentEncodingWithAllowedCharacters:(NSCharacterSet *)allowedCharacters</span><br><span class="line">NS_AVAILABLE(10_9, 7_0);</span><br></pre></td></tr></table></figure></p><p>.</p><blockquote><p>// Returns a new string made from the receiver by replacing all percent encoded sequences with the matching UTF-8 characters.<br>返回一个新的字符串由接收方通过替换所有百分比与匹配的utf - 8字符编码序列。</p></blockquote><p>#ios7.0及之后开始添加此属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nullable, readonly, copy) NSString *stringByRemovingPercentEncoding NS_AVAILABLE(10_9, 7_0);</span><br></pre></td></tr></table></figure></p><p>.</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)stringByAddingPercentEscapesUsingEncoding:(NSStringEncoding)enc</span><br></pre></td></tr></table></figure></blockquote><p> NS_DEPRECATED(10_0, 10_11, 2_0, 9_0, “Use -stringByAddingPercentEncodingWithAllowedCharacters: instead,<br> which always uses the recommended UTF-8 encoding,<br>and which encodes for a specific URL component or subcomponent<br> since each URL component or subcomponent has different rules for what characters are valid.”);</p><p>#ios9.0及之后开始弃用此方法<br>使用-stringByAddingPercentEncodingWithAllowedCharacters:相反,它总是使用推荐utf - 8编码,编码为一个特定的URL组件或子组件由于每个URL组件或子组件有不同的规则,什么角色都是有效的。</p><p>.</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)stringByReplacingPercentEscapesUsingEncoding:(NSStringEncoding)enc</span><br></pre></td></tr></table></figure></blockquote><p>NS_DEPRECATED(10_0, 10_11, 2_0, 9_0, “Use -stringByRemovingPercentEncoding instead,<br> which always uses the recommended UTF-8 encoding.”);</p><p>#ios9.0及之后开始弃用此方法<br>使用-stringByRemovingPercentEncoding相反,总是使用推荐的utf - 8编码。<br>@end</p><p>推荐文章：<br><a href="http://www.jianshu.com/p/21a21866e379" target="_blank" rel="noopener">http://www.jianshu.com/p/21a21866e379</a><br><a href="http://nshipster.cn/nscharacterset/" target="_blank" rel="noopener">http://nshipster.cn/nscharacterset/</a></p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-f5a608395b178370.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSCharacterSet"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;接口&lt;/strong&gt;里边混合：&lt;code&gt;中文&lt;/code&gt;、&lt;code&gt;空格&lt;/code&gt;、&lt;code&gt;特殊字符...&lt;/code&gt;项目很长时间了，代码量级很大，想要修改怕是几天几夜不能睡觉（稍微夸张）；&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin程序加载webView</title>
    <link href="http://yoursite.com/2017/03/05/Kotlin%E7%A8%8B%E5%BA%8F%E5%8A%A0%E8%BD%BDwebView/"/>
    <id>http://yoursite.com/2017/03/05/Kotlin程序加载webView/</id>
    <published>2017-03-05T06:45:44.000Z</published>
    <updated>2017-06-02T07:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- ![Onlyone](/image/touxiang.jpg) --><p>我的简书:<a href="http://www.jianshu.com/u/d1cabf893d7e" target="_blank" rel="noopener">http://www.jianshu.com/u/d1cabf893d7e</a><br>博客园:<a href="http://www.cnblogs.com/520rr" target="_blank" rel="noopener">http://www.cnblogs.com/520rr</a><br><a href="https://github.com/douxindong" target="_blank" rel="noopener">GitHub(douxindong)</a></p><blockquote><p>官方文档</p></blockquote><p><a href="https://developer.android.com/reference/android/webkit/WebView.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/webkit/WebView.html</a><br><img src="http://upload-images.jianshu.io/upload_images/3729815-3ea9f062fe043849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt="webView.png"><br>【这里提示要加上这段，获取网络权限】安卓要求越来越严格<br><img src="http://upload-images.jianshu.io/upload_images/3729815-0b8ab87f6a47eaa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里提示要加上这段，获取网络权限"></p><p>添加在哪里呢？<br><img src="http://upload-images.jianshu.io/upload_images/3729815-db7e59df9e8f9716.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="访问IntNet的权限.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">上代码</span><br><span class="line">        val webview = WebView(this)</span><br><span class="line">        setContentView(webview)</span><br><span class="line">        webview.settings.javaScriptEnabled = true</span><br><span class="line">        webview.setWebViewClient(WebViewClient())</span><br><span class="line">        webview.loadUrl(&quot;https://www.baidu.com&quot;)</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-8c40d61660895ab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="手写代码创建webView方法"></p><blockquote><p>下边用图形化 类似Xcode里边的xib或者故事板的原理省去了部分代码的工作量，但是不建议一开始就用，等代码熟练之后再用也不晚。<br>图形化编辑创建webView控件,注意添加ID和约束<br><img src="http://upload-images.jianshu.io/upload_images/3729815-02b07e8132e11e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="图形化编辑创建webView控件"><br>在编辑部分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myWebView.settings.javaScriptEnabled = true</span><br><span class="line">myWebView.setWebViewClient(WebViewClient())</span><br><span class="line">myWebView.loadUrl(&quot;https://www.baidu.com&quot;)</span><br></pre></td></tr></table></figure></p></blockquote><p>运行效果位置约束不是很好，后边自己研究一下：<br><img src="http://upload-images.jianshu.io/upload_images/3729815-471892480233c0dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="QQ20170526-135507.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- ![Onlyone](/image/touxiang.jpg) --&gt;
&lt;p&gt;我的简书:&lt;a href=&quot;http://www.jianshu.com/u/d1cabf893d7e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.j
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin我的第一个kotlin程序</title>
    <link href="http://yoursite.com/2017/03/02/Kotlin%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAkotlin%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2017/03/02/Kotlin我的第一个kotlin程序/</id>
    <published>2017-03-02T06:38:37.000Z</published>
    <updated>2018-12-03T08:05:58.042Z</updated>
    
    <content type="html"><![CDATA[<p>我的简书:<a href="http://www.jianshu.com/u/d1cabf893d7e" target="_blank" rel="noopener">http://www.jianshu.com/u/d1cabf893d7e</a><br>博客园:<a href="http://www.cnblogs.com/520rr" target="_blank" rel="noopener">http://www.cnblogs.com/520rr</a><br>GitHub:<a href="https://github.com/douxindong" target="_blank" rel="noopener">https://github.com/douxindong</a></p><blockquote><p>这几天被安卓2017年开发者大会刷屏了<br>《<a href="http://www.linuxidc.com/Linux/2017-05/143999.htm?from=groupmessage" target="_blank" rel="noopener">Google宣布<em>Kotlin</em>为新的Android一级开发语言</a>》</p></blockquote><p>Kotlin 是一个基于 JVM 的新的编程语言，由 <a href="http://baike.baidu.com/item/JetBrains" target="_blank" rel="noopener">JetBrains</a> 开发。<br>Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。<br>JetBrains，作为目前广受欢迎的Java IDE <a href="http://baike.baidu.com/item/IntelliJ" target="_blank" rel="noopener">IntelliJ</a> 的提供商，在 Apache 许可下已经开源其Kotlin 编程语言。<br>Kotlin已正式成为Android官方开发语言。</p><blockquote><p>列举三种可以进行kotlin开发的IDE 【Android Studio】【IntelliJ IDEA】【Eclipse】<br>下面我们用【Android Studio】来开始我们的Kotlin开发之旅（入门篇）<br>goole开发者官网<br><a href="https://developers.google.cn" target="_blank" rel="noopener">https://developers.google.cn</a><br>如果您使用Android Studio 官方 Android IDE<br><a href="https://developer.android.google.cn/studio/index.html" target="_blank" rel="noopener">https://developer.android.google.cn/studio/index.html</a><br>教程<br><a href="http://kotlinlang.org/docs/tutorials/kotlin-android.html" target="_blank" rel="noopener">http://kotlinlang.org/docs/tutorials/kotlin-android.html</a><br>中文网：<a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">如果您使用IntelliJ IDEA 教程：</span><br><span class="line">http://kotlinlang.org/docs/tutorials/getting-started.html</span><br><span class="line">如果您使用Eclipse 教程：</span><br><span class="line">http://kotlinlang.org/docs/tutorials/getting-started-eclipse.html</span><br><span class="line"></span><br><span class="line">插件配置：</span><br><span class="line">1.   cmd加逗号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![配置插件.png](http://upload-images.jianshu.io/upload_images/3729815-73ce6f1e0c98fc15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![下载配置插件.png](http://upload-images.jianshu.io/upload_images/3729815-bced92556ddfa356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)</span><br><span class="line"></span><br><span class="line">之后重启Android Studio</span><br><span class="line">把代码转化成kotlin代码</span><br><span class="line">![转换代码.png](http://upload-images.jianshu.io/upload_images/3729815-6a0205eef6dde077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)</span><br><span class="line"></span><br><span class="line">![转换后.png](http://upload-images.jianshu.io/upload_images/3729815-0438ab5adabbca48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">![配置一下](http://upload-images.jianshu.io/upload_images/3729815-546334dbabda37c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)</span><br><span class="line">点击同步一下库文件，会从服务器上下载并安装</span><br><span class="line">![点击同步一下库文件](http://upload-images.jianshu.io/upload_images/3729815-156e6d077dcd0239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)</span><br><span class="line"></span><br><span class="line">至此就配置完成kotlin环境 下边就可以开始写代码了：</span><br><span class="line">可以参考教程：http://kotlinlang.org/docs/tutorials/kotlin-android.html</span><br><span class="line">下边安装下扩展Kotlin Android Extensions</span><br></pre></td></tr></table></figure></p></blockquote><p>Kotlin Android Extensions<br>把这一句<br>apply plugin: ‘kotlin-android-extensions’</p><p><img src="http://upload-images.jianshu.io/upload_images/3729815-f15a8ff49a175ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="粘贴.png"><br><img src="http://upload-images.jianshu.io/upload_images/3729815-7c7f4c89370160a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.example.douxindong.myapplication</span><br><span class="line">import android.support.v7.app.AppCompatActivity</span><br><span class="line">import android.os.Bundle</span><br><span class="line">import android.webkit.WebViewClient</span><br><span class="line">import kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">//只写这一句代码 根据ID取出myTextView这个控件，直接赋值</span><br><span class="line">        myTextView.text = &quot;我在这里&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">效果：</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/3729815-529943e3527e6a08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的简书:&lt;a href=&quot;http://www.jianshu.com/u/d1cabf893d7e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jianshu.com/u/d1cabf893d7e&lt;/a&gt;&lt;br&gt;博客园:&lt;a h
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>blog错误导致部分文件丢失问题解决办法</title>
    <link href="http://yoursite.com/2016/07/08/blog%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E9%83%A8%E5%88%86%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2016/07/08/blog错误导致部分文件丢失问题解决办法/</id>
    <published>2016-07-08T01:41:52.000Z</published>
    <updated>2018-12-03T08:05:51.242Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="http://douxindong.github.io/" target="_blank" rel="noopener">D.Onlyone的私人技术领域</a>!</p><h2 id="博客文件丢失解决"><a href="#博客文件丢失解决" class="headerlink" title="博客文件丢失解决"></a>博客文件丢失解决</h2><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复制blog文件夹到安全地址</span><br></pre></td></tr></table></figure><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重新创建blog文件夹在，在根录下</span><br></pre></td></tr></table></figure><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拷贝原blog文件夹里边内容到该文件夹下</span><br></pre></td></tr></table></figure><h3 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">重新生成静态页面</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h3 id="step5"><a href="#step5" class="headerlink" title="step5"></a>step5</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">预览一下</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="step6"><a href="#step6" class="headerlink" title="step6"></a>step6</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">同步到网路</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到 &lt;a href=&quot;http://douxindong.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;D.Onlyone的私人技术领域&lt;/a&gt;!&lt;/p&gt;
&lt;h2 id=&quot;博客文件丢失解决&quot;&gt;&lt;a href=&quot;#博客文件丢失解决
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>葵花宝典</title>
    <link href="http://yoursite.com/2015/06/07/%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8/"/>
    <id>http://yoursite.com/2015/06/07/葵花宝典/</id>
    <published>2015-06-07T13:52:19.000Z</published>
    <updated>2017-06-12T02:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="block：👍"><a href="#block：👍" class="headerlink" title="block：👍"></a>block：👍</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//代理协议</span><br><span class="line">//block 终极宝典</span><br><span class="line">//1.block 一般用于反向传值</span><br><span class="line">//第二个界面 要求 第一个界面 做点事情</span><br><span class="line">/*</span><br><span class="line"> 1.block 必须定义在第二个界面</span><br><span class="line"> 2.调用block</span><br><span class="line"> 3.实现block</span><br><span class="line"> */</span><br><span class="line">block  实质就是一个代码块  定义好代码块  可以用于方向传值   作为中间人来使用</span><br><span class="line">在第二个界面的.h文件里面  写协议</span><br><span class="line">typedef void(^changeClolorBlock)(UIColor *);</span><br><span class="line">协议指针</span><br><span class="line">@property (nonatomic,copy) changeClolorBlock changeColor;</span><br><span class="line"></span><br><span class="line">在第二个页面.m文件里面   调用block   写要求第一个页面做的事情</span><br><span class="line">//2.</span><br><span class="line">    _changeColor([UIColor greenColor]);</span><br><span class="line"></span><br><span class="line">在第一个页面.m文件里面    实现block</span><br><span class="line">//3.</span><br><span class="line">    vc.changeColor = ^(UIColor *color)&#123;</span><br><span class="line"></span><br><span class="line">        self.view.backgroundColor = color;      </span><br><span class="line">    &#125;;</span><br><span class="line">＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊</span><br><span class="line">代理：👍</span><br><span class="line">/*</span><br><span class="line"> 代理宝典</span><br><span class="line"> //场景 代理一般是用在反向传值</span><br><span class="line"> //第二个界面向第一个界面传值</span><br><span class="line"> (1,2步是在第二个界面完成)</span><br><span class="line"> 1.定义代理协议是发生在第二个界面（协议和代理指针）</span><br><span class="line"> 2.调用协议方法</span><br><span class="line"> (3,4步是在第一个界面完成)</span><br><span class="line"> 3.使用代理,遵循协议</span><br><span class="line"> 4.实现代理方法</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>#在第二个页面的.h里面写协议<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.指定协议</span></span><br><span class="line">@protocol TwoVCDelegate &lt;NSObject&gt;</span><br><span class="line">- (<span class="keyword">void</span>)changeColor:(UIColor *)color;</span><br><span class="line">@end</span><br><span class="line"><span class="comment">//2.代理指针</span></span><br><span class="line">@property (nonatomic,assign) id &lt;TwoVCDelegate&gt;delegate;</span><br><span class="line">在第二个页面的.m里面  调用协议  代理指针 指向 一个事件</span><br><span class="line">[_delegate changeColor:[UIColor greenColor]];</span><br><span class="line">在一个页面添加代理协议&lt;TwoVCDelegate&gt;</span><br><span class="line"><span class="comment">//使用代理</span></span><br><span class="line">    vc.delegate = self;</span><br><span class="line"><span class="comment">//实现代理</span></span><br><span class="line">- (<span class="keyword">void</span>)changeColor:(UIColor *)color&#123;</span><br><span class="line">    self.view.backgroundColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##总结：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当你触发事件进入第二个页面的时候，第二个页面反向传值，需要第一个页面做一些事情，执行协议，定义指针，在返回第一个页面的触发事件里面，调用代理  把指针指向要求第一个页面做的事情，第一个页面 遵循协议 ，使用代理方法， 执行代理的事件（注意：代理的使用必须在第一个页面中，实例化第二个页面 的地方，否则不好使。）</span><br><span class="line">模式：第一个页面开辟了一套通道，例如button的点击事件中实例化第二个页面  push跳转第二个页面  第二个页面这是需要第一个页面做事情  只有当第一个页面通过点击button的按钮跳转到第二个页面时 ，代理的事件才会在第一个页面执行</span><br><span class="line">＊＊＊</span><br></pre></td></tr></table></figure></p><p>＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊</p><p>#通知：👍<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在第二个页面的.m文件里面  触发事件的事件中</span><br><span class="line">发送 要求第一个页面做的事情</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发射广播</span></span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:@<span class="string">"1234"</span> object:[UIColor greenColor]];</span><br><span class="line">在第一个页面的.m文件里面  设置接受的收音机</span><br><span class="line"><span class="comment">//需要创建一个收音机  viewDidLoad中</span></span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeColor:) name:@<span class="string">"1234"</span> object:nil];</span><br><span class="line">#pragma mark - 实现广播方法</span><br><span class="line">- (<span class="keyword">void</span>)changeColor:(NSNotification *)notifi&#123;</span><br><span class="line">    self.view.backgroundColor = notifi.object;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;block：👍&quot;&gt;&lt;a href=&quot;#block：👍&quot; class=&quot;headerlink&quot; title=&quot;block：👍&quot;&gt;&lt;/a&gt;block：👍&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>作为一个有经验的iOS工程师你这些应该最熟悉</title>
    <link href="http://yoursite.com/2015/04/04/%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%9C%89%E7%BB%8F%E9%AA%8C%E7%9A%84iOS%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BD%A0%E8%BF%99%E4%BA%9B%E5%BA%94%E8%AF%A5%E6%9C%80%E7%86%9F%E6%82%89/"/>
    <id>http://yoursite.com/2015/04/04/作为一个有经验的iOS工程师你这些应该最熟悉/</id>
    <published>2015-04-04T10:28:56.000Z</published>
    <updated>2017-06-12T02:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、strong和copy到底怎么理解他们的区别："><a href="#1、strong和copy到底怎么理解他们的区别：" class="headerlink" title="1、strong和copy到底怎么理解他们的区别："></a>1、strong和copy到底怎么理解他们的区别：</h1><p>大部分的时候NSString的属性都是copy，那copy与strong的情况下到底有什么区别呢?</p><p>我们遇到的问题是这样的：<br>  在定义一个类的property时候，为property选择strong还是copy特别注意和研究明白的，如果property是NSString或者NSArray及其子类的时候，最好选择使用copy属性修饰。为什么呢？这是为了防止赋值给它的是可变的数据，如果可变的数据发生了变化，那么该property也会发生变化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">@property (retain,nonatomic) NSString *rStr;</span><br><span class="line">@property (copy, nonatomic)   NSString *cStr;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test:</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableString *mStr = [NSMutableStringstringWithFormat:@<span class="string">"abc"</span>];</span><br><span class="line">    self.rStr   = mStr;</span><br><span class="line">    self.cStr     = mStr;</span><br><span class="line">    NSLog(@<span class="string">"mStr:%p,%p"</span>,  mStr,&amp;mStr);</span><br><span class="line">    NSLog(@<span class="string">"retainStr:%p,%p"</span>, _rStr, &amp;_rStr);</span><br><span class="line">    NSLog(@<span class="string">"copyStr:%p,%p"</span>,   _cStr, &amp;_cStr);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p><p>  假如，mStr对象的地址为0x11，也就是0x11是@“abc”的首地址，mStr变量自身在内存中的地址为0x123；<br>  当把mStr赋值给retain的rStr时，rStr对象的地址为0x11，rStr变量自身在内存中的地址为0x124；rStr与mStr指向同样的地址，他们指向的是同一个对象@“abc”，这个对象的地址为0x11，所以他们的值是一样的。<br>  当把mStr赋值给copy的cStr时，cStr对象的地址为0x22，cStr变量自身在内存中的地址0x125；cStr与mStr指向的地址是不一样的，他们指向的是不同的对象，所以copy是深复制，一个新的对象，这个对象的地址为0x22，值为@“abc”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果现在改变mStr的值：</span><br><span class="line">    [mStr appendString:@<span class="string">"de"</span>];</span><br><span class="line">    NSLog(@<span class="string">"retainStr:%@"</span>,  _rStr);</span><br><span class="line">    NSLog(@<span class="string">"copyStr:%@"</span>,    _cStr);</span><br></pre></td></tr></table></figure></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用retain的字串rStr的值：@<span class="string">"abcde"</span>,</span><br><span class="line">而使用copy的字串cStr的值:@<span class="string">"abc"</span>,</span><br><span class="line">所以，如果一般情况下，我们都不希望字串的值跟着mStr变化，所以我们一般用copy来设置string的属性。</span><br><span class="line">如果希望字串的值跟着赋值的字串的值变化，可以使用strong，retain。</span><br><span class="line">注意：上面的情况是针对于当把NSMutableString赋值给NSString的时候，才会有不同，如果是赋值是NSString对象，那么使用copy还是strong，结果都是一样的，因为NSString对象根本就不能改变自身的值，他是不可变的。</span><br><span class="line"></span><br><span class="line">把一个对象赋值给一个属性变量，当这个对象变化了，如果希望属性变量变化就使用strong属性，如果希望属性变量不跟着变化，就是用copy属性。</span><br></pre></td></tr></table></figure><h2 id="由此可以看出："><a href="#由此可以看出：" class="headerlink" title="由此可以看出："></a>由此可以看出：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对源头是NSMutableString的字符串，retain仅仅是指针引用，增加了引用计数器，这样源头改变的时候，用这种retain方式声明的变量（无论被赋值的变量是可变的还是不可变的），它也会跟着改变;而copy声明的变量，它不会跟着源头改变，它实际上是深拷贝。</span><br><span class="line"></span><br><span class="line">对源头是NSString的字符串，无论是retain声明的变量还是copy声明的变量，当第二次源头的字符串重新指向其它的地方的时候，它还是指向原来的最初的那个位置，也就是说其实二者都是指针引用，也就是浅拷贝。</span><br></pre></td></tr></table></figure><h2 id="另外说明一下，这两者对内存计数的影响都是一样的，都会增加内存引用计数，都需要在最后的时候做处理。"><a href="#另外说明一下，这两者对内存计数的影响都是一样的，都会增加内存引用计数，都需要在最后的时候做处理。" class="headerlink" title="另外说明一下，这两者对内存计数的影响都是一样的，都会增加内存引用计数，都需要在最后的时候做处理。"></a>另外说明一下，这两者对内存计数的影响都是一样的，都会增加内存引用计数，都需要在最后的时候做处理。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实说白了，对字符串为啥要用这两种方式？我觉得还是一个安全问题，比如声明的一个NSString *str变量，然后把一个NSMutableString *mStr变量的赋值给它了，如果要求str跟着mStr变化，那么就用retain;如果str不能跟着mStr一起变化，那就用copy。而对于要把NSString类型的字符串赋值给str，那两都没啥区别。不会影响安全性，内存管理也一样。</span><br></pre></td></tr></table></figure><h1 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h1><h3 id="创建一篇新博文"><a href="#创建一篇新博文" class="headerlink" title="创建一篇新博文"></a>创建一篇新博文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"索要创建的文件名"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="生成静态文件-hexo-generate（以下缩写）"><a href="#生成静态文件-hexo-generate（以下缩写）" class="headerlink" title="生成静态文件 hexo generate（以下缩写）"></a>生成静态文件 hexo generate（以下缩写）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="同步-hexo-deploy（以下缩写）"><a href="#同步-hexo-deploy（以下缩写）" class="headerlink" title="同步 hexo deploy（以下缩写）"></a>同步 hexo deploy（以下缩写）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、strong和copy到底怎么理解他们的区别：&quot;&gt;&lt;a href=&quot;#1、strong和copy到底怎么理解他们的区别：&quot; class=&quot;headerlink&quot; title=&quot;1、strong和copy到底怎么理解他们的区别：&quot;&gt;&lt;/a&gt;1、strong和co
      
    
    </summary>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>iOS即时通讯</title>
    <link href="http://yoursite.com/2015/03/01/iOS%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/"/>
    <id>http://yoursite.com/2015/03/01/iOS即时通讯/</id>
    <published>2015-03-01T03:05:10.000Z</published>
    <updated>2018-12-03T08:05:36.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS-IM开发的一些开源、框架和教程等资料"><a href="#iOS-IM开发的一些开源、框架和教程等资料" class="headerlink" title="iOS IM开发的一些开源、框架和教程等资料"></a>iOS IM开发的一些开源、框架和教程等资料</h2><h3 id="下面收集了开发即时通讯工具，如AIM、ICQ-Oscar-协议-以及Jabber-XMPP协议-的iOS客户端程序的一些开源，可以直接使用或者参考："><a href="#下面收集了开发即时通讯工具，如AIM、ICQ-Oscar-协议-以及Jabber-XMPP协议-的iOS客户端程序的一些开源，可以直接使用或者参考：" class="headerlink" title="下面收集了开发即时通讯工具，如AIM、ICQ(Oscar 协议)以及Jabber(XMPP协议)的iOS客户端程序的一些开源，可以直接使用或者参考："></a>下面收集了开发即时通讯工具，如AIM、ICQ(Oscar 协议)以及Jabber(XMPP协议)的iOS客户端程序的一些开源，可以直接使用或者参考：</h3><p>Oscar协议开发库LibOrange：<a href="https://github.com/unixpickle/LibOrange" target="_blank" rel="noopener">https://github.com/unixpickle/LibOrange</a></p><p>基于LibOrange库开啊的AIM/ICQ消息通讯工具：<a href="https://github.com/chrisballinger/Off-the-Record-iOS" target="_blank" rel="noopener">https://github.com/chrisballinger/Off-the-Record-iOS</a></p><p>XMPP协议Objective-C框架：<a href="http://code.google.com/p/xmppframework/" target="_blank" rel="noopener">http://code.google.com/p/xmppframework/</a></p><p>一些开发教程：<br>如何开发Jabber iOS客户端：<a href="https://github.com/funkyboy/Building-a-Jabber-client-for-iOS" target="_blank" rel="noopener">https://github.com/funkyboy/Building-a-Jabber-client-for-iOS</a></p><p><a href="http://code.tutsplus.com/tutorials/building-a-jabber-client-for-ios-server-setup--mobile-6958" target="_blank" rel="noopener">Building A Jabber Client For iOS: Server Setup</a><br><a href="http://code.tutsplus.com/tutorials/building-a-jabber-client-for-ios-interface-setup--mobile-7188" target="_blank" rel="noopener">Building a Jabber Client for iOS: Interface Setup</a><br><a href="http://code.tutsplus.com/tutorials/building-a-jabber-client-for-ios-xmpp-integration--mobile-7190" target="_blank" rel="noopener">Building a Jabber Client for iOS: XMPP Setup</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS-IM开发的一些开源、框架和教程等资料&quot;&gt;&lt;a href=&quot;#iOS-IM开发的一些开源、框架和教程等资料&quot; class=&quot;headerlink&quot; title=&quot;iOS IM开发的一些开源、框架和教程等资料&quot;&gt;&lt;/a&gt;iOS IM开发的一些开源、框架和教程等
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Runtime</title>
    <link href="http://yoursite.com/2014/05/24/Runtime/"/>
    <id>http://yoursite.com/2014/05/24/Runtime/</id>
    <published>2014-05-24T10:43:11.000Z</published>
    <updated>2017-06-12T02:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>重新定义你的OC世界观.这是南峰子版，笔者读过，很不错.</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><blockquote></blockquote><p>（一）<a href="http://blog.jobbole.com/79566/" target="_blank" rel="noopener">类与对象</a><br>（二）<a href="http://blog.jobbole.com/79570/" target="_blank" rel="noopener">成员变量和属性</a><br>（三）<a href="http://blog.jobbole.com/79574/" target="_blank" rel="noopener">消息和方法</a><br>（四）<a href="http://blog.jobbole.com/79580/" target="_blank" rel="noopener">Method Swizzling</a><br>（五）<a href="http://blog.jobbole.com/79583/" target="_blank" rel="noopener">协议与分类</a><br>（六）<a href="http://blog.jobbole.com/79588/0" target="_blank" rel="noopener">补充</a><br>&lt;</p><h2 id="当你读完南峰子的"><a href="#当你读完南峰子的" class="headerlink" title="当你读完南峰子的"></a>当你读完南峰子的</h2><p><a href="http://www.jianshu.com/p/e071206103a4" target="_blank" rel="noopener">1可以看看这个;</a><br><a href="http://www.jianshu.com/users/cb974750735c/latest_articles" target="_blank" rel="noopener">2深入研究Runtime,当你读完上面的内容，在读以下内容就差不多进入了一个新的境界了;</a><br><a href="http://ios.jobbole.com/85092/" target="_blank" rel="noopener">3全方位runtime装逼指南.</a></p><h2 id="内存管理深度剖析，知其然，知其所以然"><a href="#内存管理深度剖析，知其然，知其所以然" class="headerlink" title="内存管理深度剖析，知其然，知其所以然"></a>内存管理深度剖析，知其然，知其所以然</h2><p><a href="http://blog.jobbole.com/66197/" target="_blank" rel="noopener">内存管理教程和原理剖析（一）;</a><br><a href="http://blog.jobbole.com/66363/" target="_blank" rel="noopener">内存管理教程和原理剖析（二）;</a><br><a href="http://blog.jobbole.com/66369/" target="_blank" rel="noopener">内存管理教程和原理剖析（三）;</a><br><a href="http://blog.jobbole.com/66372/" target="_blank" rel="noopener">内存管理教程和原理剖析（四）;</a><br><a href="http://ios.jobbole.com/84859/" target="_blank" rel="noopener">深浅拷贝</a></p><h2 id="多线程，这一块一定要深入理解，尤其是技术总监级别的不一定懂iOS，但是一定懂内存管理和多线程"><a href="#多线程，这一块一定要深入理解，尤其是技术总监级别的不一定懂iOS，但是一定懂内存管理和多线程" class="headerlink" title="多线程，这一块一定要深入理解，尤其是技术总监级别的不一定懂iOS，但是一定懂内存管理和多线程"></a>多线程，这一块一定要深入理解，尤其是技术总监级别的不一定懂iOS，但是一定懂内存管理和多线程</h2><p><a href="http://www.open-open.com/lib/view/open1454495256105.html" target="_blank" rel="noopener">1)IOS开发之多线程技术</a><br><a href="http://www.open-open.com/lib/view/open1439907700676.html" target="_blank" rel="noopener">2)多线程总结 </a><br><a href="http://www.open-open.com/lib/view/open1454028502198.html" target="_blank" rel="noopener">3)多线程详解 ：</a><br><a href="http://ios.jobbole.com/85040/" target="_blank" rel="noopener">4)必看</a></p><h2 id="10分钟-搞定JS和iOS的交互-你必须先看这几篇文章："><a href="#10分钟-搞定JS和iOS的交互-你必须先看这几篇文章：" class="headerlink" title="10分钟 搞定JS和iOS的交互 你必须先看这几篇文章："></a>10分钟 搞定JS和iOS的交互 你必须先看这几篇文章：</h2><p><a href="http://www.open-open.com/lib/view/open1419305655562.html" target="_blank" rel="noopener">1.web前端开发与iOS终端开发的异同(http://www.open-open.com/lib/view/open1419305655562.html)</a><br><a href="http://blog.csdn.net/lizhongfu2013/article/details/9232129" target="_blank" rel="noopener">2.IOS7开发～JavaScriptCore（一）</a><br><a href="http://blog.csdn.net/lizhongfu2013/article/details/9236357" target="_blank" rel="noopener">3IOS7开发～JavaScriptCore（二）</a><br><a href="http://www.jianshu.com/p/a329cd4a67ee" target="_blank" rel="noopener">干货好文章1</a><br><a href="http://ios.jobbole.com/84491/" target="_blank" rel="noopener">干货好文章2</a><br><a href="http://www.open-open.com/lib/view/open1463553967635.html" target="_blank" rel="noopener">交互范例http://www.open-open.com/lib/view/open1463553967635.html</a><br><a href="http://www.open-open.com/lib/view/open1456311816823.html" target="_blank" rel="noopener">iOS Native加载H5中的图片</a><br><a href="http://ios.jobbole.com/85069/" target="_blank" rel="noopener">ios 视频录制的三种方式</a></p><h2 id="直播相关内容"><a href="#直播相关内容" class="headerlink" title="[直播相关内容]"></a>[直播相关内容]</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjI0NjczNQ==&amp;mid=2652365086&amp;idx=1&amp;sn=e5ab2d6a641102ec9e2b5c175678a797&amp;scene=1&amp;srcid=05223KqAHcjMGjh83QqLXOVc&amp;key=f5c31ae61525f82e0b29fa654e701eb5165093fa979d25fc601a34874dce01f520a124dfdd113d992d0e3e86eeba9e74&amp;ascene=0&amp;uin=MTk5NDM1NQ%3D%3D&amp;devicetype=iMac+MacBookPro11%2C5+OSX+OSX+10.11.4+build(15E65" target="_blank" rel="noopener">直播相关内容1</a>&amp;version=11020201&amp;pass_ticket=2vSvVDILehoRZdj1MGS0qpcfIh%2FXnQ0HhKl3H3arUtQ%3D)<br><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjI0NjczNQ==&amp;mid=2652365088&amp;idx=2&amp;sn=86e62f2ab415df27c5bba3ba171cdd54&amp;scene=1&amp;srcid=0522CBTRcjmmWfV4s8o68w4w&amp;key=f5c31ae61525f82e3f37b74d7b115678e9ed2553afb3551ea0f3dc8f920e72a918db4844d4530d8c00608ca91a21700a&amp;ascene=0&amp;uin=MTk5NDM1NQ%3D%3D&amp;devicetype=iMac+MacBookPro11%2C5+OSX+OSX+10.11.4+build(15E65" target="_blank" rel="noopener">直播相关内容2</a>&amp;version=11020201&amp;pass_ticket=2vSvVDILehoRZdj1MGS0qpcfIh%2FXnQ0HhKl3H3arUtQ%3D)</p><h2 id="著名知识点"><a href="#著名知识点" class="headerlink" title="[著名知识点]"></a>[著名知识点]</h2><p><a href="http://www.open-open.com/lib/view/open1460681498043.html" target="_blank" rel="noopener">（上）</a><br><a href="http://www.open-open.com/lib/view/open1460681420544.html" target="_blank" rel="noopener">（中）</a><br><a href="http://www.open-open.com/lib/view/open1460682694966.html" target="_blank" rel="noopener">（下）</a><br><a href="http://ios.jobbole.com/84919/" target="_blank" rel="noopener">OC最实用的runtime总结</a></p><h2 id="一个靠谱工程师必须会了解的："><a href="#一个靠谱工程师必须会了解的：" class="headerlink" title="[一个靠谱工程师必须会了解的：]"></a>[一个靠谱工程师必须会了解的：]</h2><p><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md" target="_blank" rel="noopener">必看精品1</a><br><a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8B%EF%BC%89.md" target="_blank" rel="noopener">必看精品2</a><br><a href="http://www.open-open.com/lib/view/open1382923236124.html" target="_blank" rel="noopener">必看精品3</a></p><p>##必看精品（从简单到复杂）<br><a href="http://www.open-open.com/lib/view/open1440165855942.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1440165855942.html</a><br><a href="http://www.open-open.com/lib/view/open1457952546563.html" target="_blank" rel="noopener">优酷 ：http://www.open-open.com/lib/view/open1457952546563.html</a><br><a href="http://www.open-open.com/lib/view/open1456359620073.html" target="_blank" rel="noopener">宝库 ： http://www.open-open.com/lib/view/open1456359620073.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重新定义你的OC世界观.这是南峰子版，笔者读过，很不错.&lt;/p&gt;
&lt;h2 id=&quot;快速开始&quot;&gt;&lt;a href=&quot;#快速开始&quot; class=&quot;headerlink&quot; title=&quot;快速开始&quot;&gt;&lt;/a&gt;快速开始&lt;/h2&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>更换博客主题</title>
    <link href="http://yoursite.com/2014/05/22/%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"/>
    <id>http://yoursite.com/2014/05/22/更换博客主题/</id>
    <published>2014-05-22T06:57:50.000Z</published>
    <updated>2018-12-03T08:04:32.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">进入主题链接</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语句：# 第一步 &lt;h1&gt; 标签名</span><br><span class="line">[更换主题](https:<span class="comment">//hexo.io/themes/)</span></span><br></pre></td></tr></table></figure></p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">进入配置文档</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">看文档 示例：</span><br><span class="line">$ git clone https:<span class="comment">//github.com/DrakeLeung/hexo-theme-again.git again</span></span><br><span class="line">“_config.yml” 中的theme：again</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br><span class="line">over!!!!</span><br></pre></td></tr></table></figure></p><h1 id="写作手册-Mastering-Markdown"><a href="#写作手册-Mastering-Markdown" class="headerlink" title="写作手册     Mastering Markdown"></a>写作手册     <a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener">Mastering Markdown</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="HTML5跨平台" scheme="http://yoursite.com/tags/HTML5%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>&lt;font color=#A2CD5A size=3&gt;我的私人领域开通咯&lt;/font&gt;</title>
    <link href="http://yoursite.com/2014/05/20/%E4%B8%9C%E5%93%A5%E7%A7%81%E4%BA%BA%E9%A2%86%E5%9F%9F%E5%BC%80%E9%80%9A%E5%92%AF/"/>
    <id>http://yoursite.com/2014/05/20/东哥私人领域开通咯/</id>
    <published>2014-05-20T13:05:34.000Z</published>
    <updated>2018-12-03T08:04:31.024Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到 <a href="http://douxindong.github.io/" target="_blank" rel="noopener">D.Onlyone的私人技术领域</a>! 这是我的第一个Blog ， <a href="https://mail.qq.com/" target="_blank" rel="noopener">联系我:1434619565@qq.com</a> . 如果你在工作学习中遇到什么问题, 你可以询问我，或者到<br>我的简书:<a href="http://www.jianshu.com/u/d1cabf893d7e" target="_blank" rel="noopener">http://www.jianshu.com/u/d1cabf893d7e</a><br>博客园:<a href="http://www.cnblogs.com/520rr" target="_blank" rel="noopener">http://www.cnblogs.com/520rr</a><br>GitHub:<a href="https://github.com/douxindong" target="_blank" rel="noopener">https://github.com/douxindong</a><br>查看.</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一篇新博文"><a href="#创建一篇新博文" class="headerlink" title="创建一篇新博文"></a>创建一篇新博文</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"索要创建的文件名"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="生成静态文件-hexo-generate（以下缩写）"><a href="#生成静态文件-hexo-generate（以下缩写）" class="headerlink" title="生成静态文件 hexo generate（以下缩写）"></a>生成静态文件 hexo generate（以下缩写）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="同步-hexo-deploy（以下缩写）"><a href="#同步-hexo-deploy（以下缩写）" class="headerlink" title="同步 hexo deploy（以下缩写）"></a>同步 hexo deploy（以下缩写）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到 &lt;a href=&quot;http://douxindong.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;D.Onlyone的私人技术领域&lt;/a&gt;! 这是我的第一个Blog ， &lt;a href=&quot;https://mail.qq.c
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="HTML5跨平台" scheme="http://yoursite.com/tags/HTML5%E8%B7%A8%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
</feed>
